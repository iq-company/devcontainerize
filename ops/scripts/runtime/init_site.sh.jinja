#!/usr/bin/env bash

set -e # Exit on errors

# Source the environment file to get all necessary variables
# The file is created by init_env_files.sh

DB_SCHEMA=${DB_SCHEMA:-iq_schema}

BENCH_DIR="/home/${IMAGE_USER}/bench"
APPS_DIR="/home/${IMAGE_USER}/bench/apps"

echo "Using DBMS: $DBMS"

# Wait for all external services (DB, Redis)
wait_for_services.sh

export FRAPPE_STREAM_LOGGING=true
export NEWLY_LINKED_APPS

# Ensure all apps have .pth files in site-packages
check_and_setup_pth_files.sh

# Check if node_modules needs to be initialized for locally mounted apps
while IFS= read -r app_dir; do
	if [ ! -d "$app_dir/node_modules" ]; then
		node_modules_installed=true
		app_name=$(basename "$app_dir")

		echo "Initializing node_modules for app $app_name ..."
		bench setup requirements --node $app_name
	fi
done < <(find "$APPS_DIR" -mindepth 1 -maxdepth 1 -type d)

if [ "$node_modules_installed" = true ]; then
	echo "Building assets ..."
	bench build --production
fi

# Init site
echo "Setting up site $IQ_SITE_NAME ..."
# read "default_site" property from common_site_config.json
# if var is not set already
if [ -z "$IQ_SITE_NAME" ]; then
	IQ_SITE_NAME=$(jq -r '.default_site' sites/common_site_config.json)
fi

if [ ! -d "sites/$IQ_SITE_NAME" ]; then
	if [ -z "$IQ_SITE_NAME" ]; then
		echo "IQ_SITE_NAME is empty. Please set it in .env"
		exit 1
	fi

	# Set Redis configuration before site creation/migration
	# Only set default_site if none is configured yet (avoid overwriting on test site creation)
	CURRENT_DEFAULT_SITE=$(jq -r '.default_site // empty' sites/common_site_config.json 2>/dev/null || true)
	if [ -z "$CURRENT_DEFAULT_SITE" ]; then
		bench set-config -g default_site "$IQ_SITE_NAME"
	fi
	bench set-config -g redis_cache "redis://$REDIS_CACHE"
	bench set-config -g redis_queue "redis://$REDIS_QUEUE"
	bench set-config -g redis_socketio "redis://$REDIS_QUEUE"
	bench set-config -gp socketio_port $SOCKETIO_PORT
	bench set-config -g server_script_enabled 1
	bench set-config -g developer_mode 1

	if [ "$DBMS" == "postgres" ]; then
		# check if database is already present
		RESULT=$(PGPASSWORD="$DB_ROOT_PASSWORD" psql -U postgres -h "$DB_HOST" -p "$DB_PORT" -tAc "SELECT 1 FROM pg_database WHERE datname='$DB_NAME';")

		if [ "$RESULT" == "1" ]; then
			echo "ðŸ›‘ DB '$DB_NAME' already exists on DB (but not on FS)."
			exit 1
		else
			# Determine the effective DB user (DDL mode uses DB_NAME as user)
			EFFECTIVE_DB_USER="${DB_USER:-$DB_NAME}"
			EFFECTIVE_DB_PASSWORD="${DB_PASSWORD:-$DB_SUPER_USER_PW}"

			echo "Setting up new db, user, schema ..."
			echo "  Database: $DB_NAME"
			echo "  Schema: $DB_SCHEMA"
			echo "  Super User (DDL): $DB_SUPER_USER"
			echo "  App User: $EFFECTIVE_DB_USER"

			PGPASSWORD="$DB_ROOT_PASSWORD" psql -h $DB_HOST -p $DB_PORT -U postgres -d postgres <<-EOF
				CREATE DATABASE $DB_NAME;
				CREATE USER $DB_SUPER_USER WITH PASSWORD '$DB_SUPER_USER_PW';
				GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $DB_SUPER_USER;

				CREATE SCHEMA $DB_SCHEMA AUTHORIZATION $DB_SUPER_USER;
				REVOKE ALL PRIVILEGES ON SCHEMA public FROM $DB_SUPER_USER;
				REVOKE CREATE ON SCHEMA public FROM $DB_SUPER_USER;

				-- Create app user (in DDL mode this equals DB_NAME)
				CREATE USER $EFFECTIVE_DB_USER WITH PASSWORD '$EFFECTIVE_DB_PASSWORD';
				GRANT CONNECT ON DATABASE $DB_NAME TO $EFFECTIVE_DB_USER;
				GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA $DB_SCHEMA TO $EFFECTIVE_DB_USER;
				ALTER DEFAULT PRIVILEGES IN SCHEMA $DB_SCHEMA GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO $EFFECTIVE_DB_USER;
				ALTER DEFAULT PRIVILEGES IN SCHEMA $DB_SCHEMA GRANT SELECT, USAGE ON SEQUENCES TO $EFFECTIVE_DB_USER;
				ALTER USER $EFFECTIVE_DB_USER SET search_path TO $DB_SCHEMA;
				COMMIT;
EOF

			echo "Creating site $IQ_SITE_NAME ..."
			# Always pass db-user and password (DDL mode uses DB_NAME as user)
			bench new-pg-site $IQ_SITE_NAME \
				--db-host $DB_HOST \
				--db-port $DB_PORT \
				--db-root-username $DB_SUPER_USER \
				--db-root-password $DB_SUPER_USER_PW \
				--admin-password $IQ_ADMIN_PW \
				--db-name $DB_NAME \
				--db-schema-name $DB_SCHEMA \
				--db-user "$EFFECTIVE_DB_USER" \
				--db-user-password "$EFFECTIVE_DB_PASSWORD" \
				--install-app {{ app_name }} \
				--auto-rollback
		fi

		bench --site $IQ_SITE_NAME pg-migrate --db-root-username $DB_SUPER_USER --db-root-password $DB_SUPER_USER_PW

	elif [ "$DBMS" == "mariadb" ]; then
		# check if database is already present
		RESULT=$(mysql -h "$DB_HOST" -P "$DB_PORT" -u root -p"$DB_ROOT_PASSWORD" -e "SHOW DATABASES LIKE '$DB_NAME';" | grep "$DB_NAME")

		if [ -n "$RESULT" ]; then
			echo "ðŸ›‘ DB '$DB_NAME' already exists on DB (but not on FS)."
			exit 1
		else
			echo "Setting up new db, user ..."
			mysql -h $DB_HOST -P $DB_PORT -u root -p"$DB_ROOT_PASSWORD" <<-EOF
				CREATE DATABASE $DB_NAME;
				CREATE USER '$DB_USER'@'%' IDENTIFIED BY '$DB_PASSWORD';
				GRANT ALL PRIVILEGES ON $DB_NAME.* TO '$DB_USER'@'%';
				FLUSH PRIVILEGES;
EOF

			echo "Creating site $IQ_SITE_NAME ..."
			bench new-site $IQ_SITE_NAME \
				--db-host $DB_HOST \
				--db-port $DB_PORT \
				--mariadb-root-password $DB_ROOT_PASSWORD \
				--admin-password $IQ_ADMIN_PW \
				--db-name $DB_NAME \
				--db-user $DB_USER \
				--db-password $DB_PASSWORD \
				--install-app {{ app_name }} \
				--auto-rollback
		fi

		bench --site $IQ_SITE_NAME migrate

	elif [ "$DBMS" == "sqlite" ]; then
		echo "Creating site $IQ_SITE_NAME with SQLite..."
		bench new-site $IQ_SITE_NAME \
			--db-type sqlite \
			--admin-password $IQ_ADMIN_PW \
			--install-app {{ app_name }} \
			--auto-rollback

		bench --site $IQ_SITE_NAME migrate

	else
		echo "Error: Unknown DBMS specified in .env: $DBMS" >&2
		exit 1
	fi
else
	# Site already exists - run migrations
	echo "Site $IQ_SITE_NAME already exists. Running migrations..."

	if [ "$DBMS" == "postgres" ]; then
		bench --site $IQ_SITE_NAME pg-migrate --db-root-username $DB_SUPER_USER --db-root-password $DB_SUPER_USER_PW
	else
		bench --site $IQ_SITE_NAME migrate
	fi

	echo "Migration completed."
fi

# if APP env is set, install the app if its not frappe or iq_core
if [ -n "$APP" ] && [ "$APP" != "frappe" ] && [ "$APP" != "iq_core" ]; then
	bench --site $IQ_SITE_NAME install-app "$APP"
else
	# otherwise all apps are part of the image (available in apps.txt, each line one app), also install them
	apps=$(cat /home/${IMAGE_USER}/bench/sites/apps.txt)
	for app in $apps; do
		if [ "$app" != "frappe" ] && [ "$app" != "{{ app_name }}" ]; then
			bench --site $IQ_SITE_NAME install-app "$app"
		fi
	done
fi

# if IQ_SITE_NAME starts with "test_", then set-config to make it a test site
if [[ $IQ_SITE_NAME == test_* ]]; then
	bench --site $IQ_SITE_NAME set-config allow_tests true
fi

# When started from devcontainers (DEV_CONTAINER=1), several further adjustments for vscode will be made
if [ -n "$DEV_CONTAINER" ]; then
	# Placeholder for any future devcontainer-specific logic
	echo "Devcontainer-specific setup can be added here."
fi
