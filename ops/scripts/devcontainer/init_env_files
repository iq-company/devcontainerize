#!/bin/bash

# Script to create .env (shared) and .env.STAGE files
# Called by VSCode devcontainer initializeCommand or bench ops stage env

set -e

# Determine ops directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
OPS_DIR="$(cd "$SCRIPT_DIR/../.." && pwd)"
ENV_DIR="$OPS_DIR/env"
TEMPLATES_DIR="$OPS_DIR/env-templates"

# Ensure env directory exists
mkdir -p "$ENV_DIR"

# =============================================================================
# Interpolation function - replaces all known placeholders in a string
# Usage: result=$(interpolate_template "$content")
# =============================================================================
interpolate_template() {
	local content="$1"

	# Stage and project
	content="${content//\{\{stage\}\}/$STAGE_NAME}"
	content="${content//\{\{random_lower\}\}/$RANDOM_LOWER}"

	# Passwords and credentials
	content="${content//\{\{random_password\}\}/$IQ_ADMIN_PW_VAL}"
	content="${content//\{\{db_super_user\}\}/$DB_SUPER_USER_VAL}"
	content="${content//\{\{db_super_user_pw\}\}/$DB_SUPER_USER_PW_VAL}"
	content="${content//\{\{db_root_password\}\}/$DB_ROOT_PASSWORD_VAL}"
	content="${content//\{\{db_password\}\}/$DB_PASSWORD_VAL}"

	# Database settings
	content="${content//\{\{dbms\}\}/$DBMS}"
	content="${content//\{\{db_host\}\}/$DB_HOST_VAL}"
	content="${content//\{\{db_port\}\}/$DB_PORT_VAL}"

	# Dev-specific (only set for dev stage)
	content="${content//\{\{uid\}\}/$CURRENT_UID}"
	content="${content//\{\{gid\}\}/$CURRENT_GID}"
	content="${content//\{\{vscode_settings_path\}\}/$VSCODE_SETTINGS_PATH}"

	echo "$content"
}

# Interpolate a template file and write to target
# Usage: interpolate_file "source_template" "target_file"
interpolate_file() {
	local source="$1"
	local target="$2"

	if [ ! -f "$source" ]; then
		echo "Warning: Template not found: $source"
		return 1
	fi

	local content
	content=$(cat "$source")
	content=$(interpolate_template "$content")
	echo "$content" > "$target"
}

# Append interpolated template content to a file
# Usage: append_interpolated "source_template" "target_file"
append_interpolated() {
	local source="$1"
	local target="$2"

	if [ ! -f "$source" ]; then
		return 0  # Silently skip if addon doesn't exist
	fi

	local content
	content=$(cat "$source")
	content=$(interpolate_template "$content")
	echo "" >> "$target"
	echo "$content" >> "$target"
}

# Support custom env file suffix (e.g., ".staging" for .env.staging)
# Default is ".dev" for .env.dev (dev stage)
ENV_SUFFIX="${ENV_FILE_SUFFIX:-.dev}"
STAGE_NAME="${ENV_SUFFIX#.}"  # Remove leading dot (e.g., ".dev" -> "dev")

# Target files
SHARED_ENV_FILE="$ENV_DIR/.env"
STAGE_ENV_FILE="$ENV_DIR/.env${ENV_SUFFIX}"

# Template files
SHARED_TEMPLATE="$TEMPLATES_DIR/env.shared.template"
STAGE_TEMPLATE="$TEMPLATES_DIR/env.template"
DEV_ADDON_TEMPLATE="$TEMPLATES_DIR/env.dev.addon.template"

# --- Handle DBMS selection ---

if [ -n "$1" ]; then
	DBMS=$(echo "$1" | tr '[:upper:]' '[:lower:]')
elif [ -z "$DBMS" ]; then
	DBMS="postgres"
else
	DBMS=$(echo "$DBMS" | tr '[:upper:]' '[:lower:]')
fi

if [[ "$DBMS" != "postgres" && "$DBMS" != "mariadb" && "$DBMS" != "sqlite" ]]; then
	echo "Warning: Invalid DBMS ($DBMS). Defaulting to postgres."
	DBMS="postgres"
fi

# DB host/port based on DBMS
DB_HOST_VAL=""
DB_PORT_VAL=""
case "$DBMS" in
	postgres) DB_HOST_VAL="db"; DB_PORT_VAL="5432" ;;
	mariadb)  DB_HOST_VAL="db"; DB_PORT_VAL="3306" ;;
	sqlite)   DB_HOST_VAL="localhost"; DB_PORT_VAL="" ;;
esac

echo "Stage: $STAGE_NAME"
echo "DBMS: $DBMS"

# =============================================================================
# 1. Create shared .env if it doesn't exist
# =============================================================================

if [ -f "$SHARED_ENV_FILE" ]; then
	echo "✓ Shared .env already exists"
else
	echo "Creating shared .env..."
	if [ -f "$SHARED_TEMPLATE" ]; then
		cp "$SHARED_TEMPLATE" "$SHARED_ENV_FILE"
		echo "✓ Created $SHARED_ENV_FILE"
	else
		echo "Warning: Shared template not found: $SHARED_TEMPLATE"
	fi
fi

# =============================================================================
# 2. Merge .env + .env.STAGE to compose/.env for Docker Compose
# =============================================================================
# Docker Compose needs .env in the project directory for ${VAR} substitution
# in YAML files (e.g., image: "${IQ_IMAGE}", COMPOSE_PROJECT_NAME).
# The env_file: directive only loads vars into container environment, not for YAML.
# We merge both files so all variables are available for interpolation.

COMPOSE_DIR="$OPS_DIR/compose"
COMPOSE_ENV_COPY="$COMPOSE_DIR/.env"

# =============================================================================
# 3. Create stage-specific .env.STAGE if it doesn't exist
# =============================================================================

if [ -f "$STAGE_ENV_FILE" ]; then
	echo "✓ Stage file $STAGE_ENV_FILE already exists"
else
	echo "Creating $STAGE_ENV_FILE..."

	# --- Gather required values ---
	CURRENT_UID=$(id -u)
	CURRENT_GID=$(id -g)
	RANDOM_LOWER=$(LC_ALL=C tr -dc a-z </dev/urandom | head -c 5)

	# VSCode settings path (for dev stage)
	if [ -d "${HOME}/Library/Application Support/Code/User/" ]; then
		VSCODE_SETTINGS_PATH="${HOME}/Library/Application Support/Code/User/"
	elif [ -d "${HOME}/.config/Code/User/" ]; then
		VSCODE_SETTINGS_PATH="${HOME}/.config/Code/User/"
	else
		VSCODE_SETTINGS_PATH="/tmp/.vscode-host"
	fi

	# --- Generate random passwords and user names ---
	IQ_ADMIN_PW_VAL=$(LC_ALL=C tr -dc 'a-zA-Z0-9' </dev/urandom | head -c 16)
	DB_SUPER_USER_VAL="ddl_user_$(LC_ALL=C tr -dc a-z0-9 </dev/urandom | head -c 5)"
	DB_SUPER_USER_PW_VAL=$(LC_ALL=C tr -dc 'a-zA-Z0-9' </dev/urandom | head -c 16)
	DB_ROOT_PASSWORD_VAL=$(LC_ALL=C tr -dc 'a-zA-Z0-9' </dev/urandom | head -c 16)
	DB_PASSWORD_VAL=$(LC_ALL=C tr -dc 'a-zA-Z0-9' </dev/urandom | head -c 16)

	# --- Create from template using interpolation function ---
	interpolate_file "$STAGE_TEMPLATE" "$STAGE_ENV_FILE"

	# --- Append DBMS-specific addon if exists ---
	DBMS_ADDON="$TEMPLATES_DIR/env.$DBMS.addon.template"
	if [ -f "$DBMS_ADDON" ]; then
		echo "" >> "$STAGE_ENV_FILE"
		echo "# --- $DBMS-specific settings ---" >> "$STAGE_ENV_FILE"
		append_interpolated "$DBMS_ADDON" "$STAGE_ENV_FILE"
	fi

	# --- Append dev-specific addon for dev stage ---
	if [ "$STAGE_NAME" = "dev" ]; then
		append_interpolated "$DEV_ADDON_TEMPLATE" "$STAGE_ENV_FILE"
	fi

	echo "✓ Created $STAGE_ENV_FILE"
fi

# =============================================================================
# 4. Merge .env + .env.STAGE to compose/.env
# =============================================================================
# This merged file is needed for Docker Compose YAML interpolation.
# Variables like COMPOSE_PROJECT_NAME, IQ_IMAGE must be available during parsing.

if [ -f "$SHARED_ENV_FILE" ] && [ -f "$STAGE_ENV_FILE" ]; then
	{
		echo "# ============================================================================="
		echo "# AUTO-GENERATED MERGED FILE - DO NOT EDIT!"
		echo "# ============================================================================="
		echo "# Sources: ops/env/.env + ops/env/.env.$STAGE_NAME"
		echo "# This file is overwritten on every devcontainer start."
		echo "#"
		echo "# Why this merged copy exists:"
		echo "# Docker Compose needs .env in the project directory (ops/compose/) for"
		echo "# \${VAR} interpolation in YAML files (e.g., image: \"\${IQ_IMAGE}\")."
		echo "# Variables like COMPOSE_PROJECT_NAME are also read from here."
		echo "# The env_file: directive only loads vars into container environment."
		echo "#"
		echo "# To change settings, edit: ops/env/.env or ops/env/.env.$STAGE_NAME"
		echo "# ============================================================================="
		echo ""
		echo "# --- From ops/env/.env (shared) ---"
		cat "$SHARED_ENV_FILE"
		echo ""
		echo "# --- From ops/env/.env.$STAGE_NAME (stage-specific) ---"
		cat "$STAGE_ENV_FILE"
	} > "$COMPOSE_ENV_COPY"
	echo "✓ Merged .env + .env.$STAGE_NAME to compose/.env"
fi

exit 0
