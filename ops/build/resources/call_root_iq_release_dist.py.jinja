#!/usr/bin/env python3
"""
Execute release cleanup tasks during Docker image build.

Runs as root (bench commands don't allow root) to delete system files.
Reads cleanup tasks from `ops_release_cleanup` hooks in all installed apps.
"""
import importlib
import os
import subprocess
import sys

# Add apps to Python path
apps_path = os.environ.get("PYTHON_PATH", "/home/{{ image_user }}/bench/apps")
sys.path.insert(0, apps_path)

import frappe

# Initialize frappe minimally
frappe.init("")

# Collect cleanup tasks from all apps
all_cleanup_tasks = []
bench_path = os.path.dirname(apps_path)
sites_path = os.path.join(bench_path, "sites")
linked_apps = frappe.get_all_apps(False, sites_path)

for app_name in linked_apps:
    all_cleanup_tasks.extend(frappe.get_hooks("ops_release_cleanup", app_name=app_name))

# We're in Docker build, so docker won't be available
during_build = True

print(f"Running {len(all_cleanup_tasks)} release cleanup tasks...")

for cleanup_task in all_cleanup_tasks:
    if cleanup_task.get("context") == "only_during_build" and not during_build:
        continue

    if "function" in cleanup_task:
        function_path = cleanup_task["function"]
        module_path, function_name = function_path.rsplit(".", 1)
        try:
            module = importlib.import_module(module_path)
            function = getattr(module, function_name)
            print(f"Executing function: {function_path}")
            function()
        except Exception as e:
            print(f"Error executing function {function_path}: {e}")

    elif "bash" in cleanup_task:
        bash_command = cleanup_task["bash"]
        print(f"Executing bash: {bash_command}")
        try:
            subprocess.run(bash_command, shell=True, check=True)
        except subprocess.CalledProcessError as e:
            print(f"Error executing bash: {e}")

    elif "script" in cleanup_task:
        for app in linked_apps:
            script_path = os.path.join(frappe.get_app_path(app), cleanup_task["script"])
            if os.path.exists(script_path):
                print(f"Executing script: {script_path}")
                try:
                    if script_path.endswith(".py"):
                        subprocess.run([sys.executable, script_path], check=True)
                    else:
                        subprocess.run(["bash", script_path], check=True)
                except subprocess.CalledProcessError as e:
                    print(f"Error executing script: {e}")
                break

print("Release cleanup complete.")

