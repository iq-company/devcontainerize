#!/usr/bin/env python3
"""
Execute release cleanup tasks during Docker image build.

Runs as root (bench commands don't allow root) to delete system files.
Reads cleanup tasks from `ops_release_cleanup` hooks in all installed apps.

NOTE: This script does NOT use frappe.init() because during Docker build
there is no site configuration. Instead, it directly imports hooks from apps.
"""
import importlib
import os
import subprocess
import sys

# Add apps to Python path
apps_path = os.environ.get("PYTHON_PATH", "/home/{{ image_user }}/bench/apps")
sys.path.insert(0, apps_path)

# Discover installed apps by scanning the apps directory
def get_installed_apps():
    """Get list of installed apps by scanning the apps directory."""
    apps = []
    if os.path.isdir(apps_path):
        for name in os.listdir(apps_path):
            app_path = os.path.join(apps_path, name)
            # Check if it's a valid Python package with hooks
            if os.path.isdir(app_path) and os.path.exists(os.path.join(app_path, name, "__init__.py")):
                apps.append(name)
    return apps

# Get ops_release_cleanup hooks from an app
def get_app_hooks(app_name):
    """Import and return ops_release_cleanup hooks from an app."""
    hooks = []
    try:
        # Try to import ops_hooks first (preferred location)
        try:
            ops_hooks = importlib.import_module(f"{app_name}.ops_hooks")
            if hasattr(ops_hooks, "ops_release_cleanup"):
                hooks.extend(ops_hooks.ops_release_cleanup)
        except ImportError:
            pass

        # Also check main hooks.py
        try:
            main_hooks = importlib.import_module(f"{app_name}.hooks")
            if hasattr(main_hooks, "ops_release_cleanup"):
                hooks.extend(main_hooks.ops_release_cleanup)
        except ImportError:
            pass
    except Exception as e:
        print(f"Warning: Could not load hooks from {app_name}: {e}")
    return hooks

# Collect cleanup tasks from all apps
all_cleanup_tasks = []
installed_apps = get_installed_apps()
print(f"Found apps: {installed_apps}")

for app_name in installed_apps:
    hooks = get_app_hooks(app_name)
    all_cleanup_tasks.extend(hooks)

# We're in Docker build, so docker won't be available
during_build = True

print(f"Running {len(all_cleanup_tasks)} release cleanup tasks...")

for cleanup_task in all_cleanup_tasks:
    if cleanup_task.get("context") == "only_during_build" and not during_build:
        continue

    if "function" in cleanup_task:
        function_path = cleanup_task["function"]
        module_path, function_name = function_path.rsplit(".", 1)
        try:
            module = importlib.import_module(module_path)
            function = getattr(module, function_name)
            print(f"Executing function: {function_path}")
            function()
        except Exception as e:
            print(f"Error executing function {function_path}: {e}")

    elif "bash" in cleanup_task:
        bash_command = cleanup_task["bash"]
        print(f"Executing bash: {bash_command}")
        try:
            subprocess.run(bash_command, shell=True, check=True)
        except subprocess.CalledProcessError as e:
            print(f"Error executing bash: {e}")

    elif "script" in cleanup_task:
        for app in installed_apps:
            # Script path is relative to app directory (e.g., "../ops/build/resources/container-reduce.sh")
            app_dir = os.path.join(apps_path, app, app)
            script_path = os.path.normpath(os.path.join(app_dir, cleanup_task["script"]))
            if os.path.exists(script_path):
                print(f"Executing script: {script_path}")
                try:
                    if script_path.endswith(".py"):
                        subprocess.run([sys.executable, script_path], check=True)
                    else:
                        subprocess.run(["bash", script_path], check=True)
                except subprocess.CalledProcessError as e:
                    print(f"Error executing script: {e}")
                break

print("Release cleanup complete.")
