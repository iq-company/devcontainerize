#!/usr/bin/env python3
"""Deduplicate node_modules across Frappe bench apps.

After `bench setup requirements --node`, every app gets its own node_modules/
directory. Many packages (e.g. rollup, esbuild, vue, …) are installed in
identical versions across frappe, iq_core, and potentially more apps.

This script:
  1. Scans all apps/<app>/node_modules/ for top-level packages
  2. Groups packages by (name, version)
  3. For duplicates: keeps ONE canonical copy and replaces the rest with
     relative symlinks

Run AFTER `bench build` so the build can resolve packages normally.
The symlinks are followed transparently at runtime and in subsequent builds.

Usage:
    python3 dedup_node_modules.py /home/iqa/bench/apps
"""

import json
import os
import shutil
import sys
from collections import defaultdict
from pathlib import Path


def iter_top_level_packages(apps_dir: Path):
    """Yield (app_name, pkg_name, version, pkg_path) for every top-level
    package in every app's node_modules."""

    for app_dir in sorted(apps_dir.iterdir()):
        nm_dir = app_dir / "node_modules"
        if not nm_dir.is_dir():
            continue

        for entry in sorted(nm_dir.iterdir()):
            if entry.name.startswith(".") or entry.is_symlink():
                continue

            if entry.name.startswith("@"):
                # Scoped package (@scope/name)
                if not entry.is_dir():
                    continue
                for sub in sorted(entry.iterdir()):
                    if sub.is_symlink() or not sub.is_dir():
                        continue
                    pkg_name = f"{entry.name}/{sub.name}"
                    version = _read_version(sub / "package.json")
                    if version:
                        yield app_dir.name, pkg_name, version, sub
            else:
                if not entry.is_dir():
                    continue
                version = _read_version(entry / "package.json")
                if version:
                    yield app_dir.name, entry.name, version, entry


def _read_version(pkg_json: Path):
    """Read the 'version' field from a package.json, or return None."""
    try:
        if pkg_json.is_file():
            return json.loads(pkg_json.read_text()).get("version")
    except (json.JSONDecodeError, OSError):
        pass
    return None


def _dir_size(path: Path) -> int:
    """Return total size (bytes) of all regular files under *path*."""
    return sum(f.stat().st_size for f in path.rglob("*") if f.is_file())


def dedup(apps_dir: Path):
    """Deduplicate node_modules across all apps under *apps_dir*."""

    # Build groups: (pkg_name, version) → [(app_name, path), …]
    groups = defaultdict(list)
    for app_name, pkg_name, version, pkg_path in iter_top_level_packages(apps_dir):
        groups[(pkg_name, version)].append((app_name, pkg_path))

    deduped_count = 0
    saved_bytes = 0

    for (pkg_name, version), entries in sorted(groups.items()):
        if len(entries) < 2:
            continue

        # First entry becomes the canonical copy
        canonical_app, canonical_path = entries[0]

        for dup_app, dup_path in entries[1:]:
            pkg_size = _dir_size(dup_path)

            # Remove duplicate directory
            shutil.rmtree(dup_path)

            # Create relative symlink  (../../<canonical_app>/node_modules/…)
            rel_target = os.path.relpath(canonical_path, dup_path.parent)
            os.symlink(rel_target, dup_path)

            deduped_count += 1
            saved_bytes += pkg_size
            print(f"  {pkg_name}@{version}: {dup_app} → {canonical_app}")

    saved_mb = saved_bytes / (1024 * 1024)
    print(f"\nDeduplicated {deduped_count} packages, saved ~{saved_mb:.1f} MB")
    return deduped_count


def main():
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <apps-directory>")
        sys.exit(1)

    apps_dir = Path(sys.argv[1])
    if not apps_dir.is_dir():
        print(f"Error: {apps_dir} is not a directory")
        sys.exit(1)

    print(f"Deduplicating node_modules across apps in {apps_dir} ...")
    dedup(apps_dir)


if __name__ == "__main__":
    main()
