#!/usr/bin/env python3
"""
Setup script for installing Bench and custom apps.
This script is called during Docker image build to set up the Frappe bench environment.

Usage in Dockerfile:
    python3 setup_bench_apps.py \
        --frappe-ref version-15 \
        --frappe-path https://github.com/frappe/frappe \
        --custom-apps "https://github.com/org/app1#branch,/local/path/app2" \
        --home-dir /home/frappe \
        --github-user x-oauth-basic \
        --github-token ${GITHUB_TOKEN}

Custom apps format:
    - Remote: https://github.com/org/app#branch
    - Remote with ref: https://github.com/org/app#v1.0.0
    - Local path: /opt/apps/my_app
"""

import argparse
import json
import os
import shutil
import subprocess
import sys
from pathlib import Path
from typing import List, Optional
from urllib.parse import urlparse


# Configuration - can be overridden via environment or arguments
DEFAULT_APP_NAME = "{{ app_name }}"
DEFAULT_HOME_DIR = "/home/{{ image_user }}"
DEFAULT_FRAPPE_REF = "{{ frappe_ref }}"


def run_command(cmd: List[str], cwd: str = None, env: dict = None) -> None:
    """Run a shell command with proper error handling."""
    merged_env = {**os.environ, **(env or {})}
    try:
        subprocess.run(cmd, check=True, cwd=cwd, env=merged_env)
    except subprocess.CalledProcessError as e:
        print(f"Error executing command: {' '.join(cmd)}")
        print(f"Exit code: {e.returncode}")
        sys.exit(e.returncode)


def setup_github_credentials(github_user: str, github_token: str) -> Optional[Path]:
    """
    Set up GitHub credentials in .netrc file if token is provided.
    Returns the path to the .netrc file or None if no token was provided.
    """
    if not github_token:
        return None

    netrc_path = Path.home() / ".netrc"
    with open(netrc_path, "w") as f:
        f.write(f"machine github.com login {github_user} password {github_token}\n")

    os.chmod(netrc_path, 0o600)
    return netrc_path


def cleanup_github_credentials(netrc_path: Optional[Path]) -> None:
    """Remove GitHub credentials file if it exists."""
    if netrc_path and netrc_path.exists():
        netrc_path.unlink()


def parse_app_url(app_url: str) -> tuple:
    """
    Parse an app URL to extract app name, URL, and ref.

    Formats:
        - https://github.com/org/app#branch -> (app, url, branch)
        - https://github.com/org/app#v1.0.0 -> (app, url, v1.0.0)
        - /local/path/app -> (app, /local/path/app, None)
        - app_name:https://url#ref -> (app_name, url, ref)

    Returns (app_name, url, ref)
    """
    ref = None
    if "#" in app_url:
        app_url, ref = app_url.split("#", 1)

    if app_url.startswith("https:") or app_url.startswith("git@"):
        parsed_url = urlparse(app_url)
        app_name = os.path.basename(parsed_url.path)
        if app_name.endswith(".git"):
            app_name = app_name[:-4]
    elif app_url.startswith("/"):
        app_name = os.path.basename(app_url)
    else:
        if ":" in app_url and not app_url.startswith("/"):
            app_name, app_url = app_url.split(":", 1)
        else:
            app_name = app_url

    return app_name, app_url, ref


def main():
    parser = argparse.ArgumentParser(description="Set up bench with custom apps")
    parser.add_argument("--frappe-ref", default=DEFAULT_FRAPPE_REF,
                        help="Frappe git reference (branch, tag, or commit)")
    parser.add_argument("--frappe-path", default="https://github.com/frappe/frappe",
                        help="Frappe repository URL")
    parser.add_argument("--custom-apps", default="",
                        help="Comma-separated list of custom app URLs to install")
    parser.add_argument("--local-app-path", default=f"/opt/apps/{DEFAULT_APP_NAME}",
                        help="Path to local app copied into container")
    parser.add_argument("--home-dir", default=DEFAULT_HOME_DIR,
                        help="Home directory where bench will be installed")
    parser.add_argument("--github-user", default="x-oauth-basic",
                        help="GitHub username for authentication")
    parser.add_argument("--github-token", default="",
                        help="GitHub token for authentication")
    parser.add_argument("--skip-assets", action="store_true",
                        help="Skip building frontend assets")
    parser.add_argument("--production", action="store_true", default=True,
                        help="Build assets for production")
    args = parser.parse_args()

    netrc_path = setup_github_credentials(args.github_user, args.github_token)

    try:
        home_dir = Path(args.home_dir)
        bench_dir = home_dir / "bench"
        local_app_path = Path(args.local_app_path)
        local_app_name = local_app_path.name

        # Clean start
        if bench_dir.exists():
            print(f"Removing existing bench directory: {bench_dir}")
            shutil.rmtree(str(bench_dir))

        # Create temporary bench structure for init
        tmp_bench_dir = Path("/tmp/bench")
        tmp_bench_apps_dir = tmp_bench_dir / "apps"
        tmp_bench_sites_dir = tmp_bench_dir / "sites"

        tmp_bench_apps_dir.mkdir(parents=True, exist_ok=True)
        tmp_bench_sites_dir.mkdir(parents=True, exist_ok=True)

        # Create empty apps.txt
        (tmp_bench_sites_dir / "apps.txt").touch()

        # Clone Frappe
        print(f"Cloning Frappe from {args.frappe_path} @ {args.frappe_ref}")
        run_command([
            "git", "clone", "--depth", "1",
            "--branch", args.frappe_ref,
            args.frappe_path,
            str(tmp_bench_apps_dir / "frappe")
        ])

        # Run Frappe patches if they exist
        frappe_patches = local_app_path / "ops" / "build" / "resources" / "frappe-patches.sh"
        if frappe_patches.exists():
            print(f"Running Frappe patches: {frappe_patches}")
            run_command(["bash", str(frappe_patches)], cwd=str(home_dir))

        # Initialize bench
        print("Initializing bench...")
        run_command([
            "bench", "init",
            "--clone-from", str(tmp_bench_dir),
            "--clone-without-update",
            "--no-procfile",
            "--no-backups",
            "--skip-redis-config-generation",
            "--skip-assets",
            "--verbose",
            str(bench_dir)
        ])

        # Install additional pip packages
        env_bin_dir = bench_dir / "env" / "bin"
        run_command([
            str(env_bin_dir / "pip"), "install", "frappe-bench"
        ], cwd=str(bench_dir))

        # Create common site config
        config_path = bench_dir / "sites" / "common_site_config.json"
        config_path.write_text("{}")

        # Cleanup temp
        shutil.rmtree(tmp_bench_dir)

        # Initialize apps.txt with frappe
        apps_txt = bench_dir / "sites" / "apps.txt"
        apps_txt.write_text("frappe\n")

        # Collect all apps to install
        app_urls = []

        # Add local app first
        if local_app_path.exists():
            app_urls.append(str(local_app_path))

        # Add custom apps
        if args.custom_apps:
            app_urls.extend([a.strip() for a in args.custom_apps.split(",") if a.strip()])

        print(f"Installing apps: {app_urls}")

        installed_apps = ["frappe"]

        for app_url in app_urls:
            print(f"Processing app: {app_url}")
            app_name, url, ref = parse_app_url(app_url)

            if app_url.startswith("/"):
                # Local app path - move to bench/apps
                print(f"Installing local app {app_name} from {app_url}")
                shutil.move(app_url, str(bench_dir / "apps"))

                # Add to apps.txt
                with open(apps_txt, "a") as f:
                    f.write(f"{app_name}\n")
            else:
                # Remote repository
                cmd = ["bench", "get-app", url, "--skip-assets"]
                if ref:
                    cmd.extend(["--branch", ref])
                    print(f"Installing app {app_name} from {url} @ {ref}")
                else:
                    print(f"Installing app {app_name} from {url}")
                run_command(cmd, cwd=str(bench_dir))

            installed_apps.append(app_name)

            # Update common_site_config.json
            config = json.loads(config_path.read_text())
            if "install_apps" not in config:
                config["install_apps"] = []
            if app_name not in config["install_apps"]:
                config["install_apps"].append(app_name)
            config_path.write_text(json.dumps(config))

        # Run app-specific patches if they exist
        app_patches = bench_dir / "apps" / local_app_name / "ops" / "build" / "resources" / "app-patches.sh"
        if app_patches.exists():
            print(f"Running app patches: {app_patches}")
            run_command(["bash", str(app_patches)], cwd=str(home_dir))

        # Setup requirements
        print("Installing Python requirements...")
        run_command(["bench", "setup", "requirements", "--python"], cwd=str(bench_dir))

        print("Installing Node requirements...")
        run_command(["bench", "setup", "requirements", "--node"], cwd=str(bench_dir))

        # Build assets
        if not args.skip_assets:
            build_apps = ",".join(installed_apps)
            build_cmd = ["bench", "build", "--apps", build_apps]
            if args.production:
                build_cmd.append("--production")
            print(f"Building assets for: {build_apps}")
            run_command(build_cmd, cwd=str(bench_dir))

        # Handle assets directory (move and symlink for volume mounting)
        sites_assets_dir = bench_dir / "sites_assets"
        assets_dir = bench_dir / "sites" / "assets"

        if assets_dir.exists() and not assets_dir.is_symlink():
            shutil.move(str(assets_dir), str(sites_assets_dir))
            os.symlink(str(sites_assets_dir), str(assets_dir))

        # Create extension_paths.pth for runtime pip installs
        python_version = f"python{sys.version_info.major}.{sys.version_info.minor}"
        extension_path = bench_dir / "env" / "lib" / python_version / "site-packages" / "extension_paths.pth"
        extension_path.write_text(f"{bench_dir}/sites/extensions/pip_packages\n")

        # Clean up unnecessary files
        for pattern in [".git", ".github", ".cache", ".config", ".yarn"]:
            for path in (bench_dir / "apps").glob(f"**/{pattern}"):
                if path.is_dir():
                    shutil.rmtree(path)

        print("Setup complete!")

    finally:
        cleanup_github_credentials(netrc_path)


if __name__ == "__main__":
    main()
