"""
Modular Update System for Stage Deployments.

This module provides a step-based update orchestration with hooks for customization.
Each step can be run individually via --only-<step> CLI flags.

Hook system:
    - Hooks are defined in hooks.py as ops_update_hooks = {
          "pre_migrate": [{"id": "backup", "order": 10, "function": "module.path.func"}],
          "post_migrate": [...]
      }
    - Hooks with same ID are deduplicated (later definition wins)
    - Hooks are sorted by order, then executed in sequence
"""

import importlib
import json
import os
import subprocess
import time
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Callable, Optional

import click
import frappe


# =============================================================================
# Data Classes
# =============================================================================

@dataclass
class UpdateContext:
    """Shared context for update steps."""
    stage_name: str
    compose_dir: Path
    env_dir: Path
    app_root: Path

    # Runtime state
    env: dict = field(default_factory=dict)
    base_cmd: list = field(default_factory=list)

    # Image management
    image_name: str = ""
    rollback_tag: str = ""
    tagged_images: dict = field(default_factory=dict)
    has_registry: bool = False
    was_running: bool = False

    # Env files
    shared_env_file: Path = None
    stage_env_file: Path = None
    env_file_name: str = ".env.dev"

    # Error tracking
    errors: list = field(default_factory=list)

    def add_error(self, step: str, message: str):
        """Add an error to the context."""
        self.errors.append({"step": step, "message": message, "time": datetime.now().isoformat()})


@dataclass
class HookDefinition:
    """Definition of a hook."""
    id: str
    order: int
    function: str
    description: str = ""


# =============================================================================
# Base Step Class
# =============================================================================

class UpdateStep(ABC):
    """Base class for update steps."""

    # Step identification
    name: str = "base"
    description: str = "Base update step"

    # Execution order (lower = earlier)
    order: int = 50

    # Step configuration
    can_run_isolated: bool = True  # Can be run with --only-<step>
    requires_running_stack: bool = False  # Needs stack to be running

    def __init__(self, ctx: UpdateContext):
        self.ctx = ctx

    @abstractmethod
    def execute(self) -> bool:
        """Execute the step. Returns True on success, False on failure."""
        pass

    def rollback(self) -> bool:
        """Rollback this step. Override if rollback is needed."""
        return True

    def should_skip(self) -> tuple[bool, str]:
        """Check if step should be skipped. Returns (skip, reason)."""
        return False, ""

    def log(self, message: str, level: str = "info"):
        """Log a message."""
        prefix = {"info": "â„¹ï¸", "success": "âœ…", "error": "âŒ", "warning": "âš ï¸"}.get(level, "")
        click.echo(f"{prefix} [{self.name}] {message}")


# =============================================================================
# Update Steps Implementation
# =============================================================================

class MaintenanceModeStep(UpdateStep):
    """Enable/disable maintenance mode on the site."""

    name = "maintenance"
    description = "Enable maintenance mode"
    order = 10

    def __init__(self, ctx: UpdateContext, enable: bool = True):
        super().__init__(ctx)
        self.enable = enable

    def execute(self) -> bool:
        action = "enable" if self.enable else "disable"
        self.log(f"{'Enabling' if self.enable else 'Disabling'} maintenance mode...")

        try:
            # Use bench command to set maintenance mode
            site_name = os.environ.get("IQ_SITE_NAME", "")
            if not site_name:
                self.log("No IQ_SITE_NAME set, skipping maintenance mode", "warning")
                return True

            cmd = [
                "bench", "--site", site_name,
                "set-maintenance-mode", "on" if self.enable else "off"
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.returncode != 0:
                self.log(f"Failed to {action} maintenance mode: {result.stderr}", "warning")
                # Non-critical, continue
            else:
                self.log(f"Maintenance mode {action}d", "success")

            return True

        except Exception as e:
            self.log(f"Error setting maintenance mode: {e}", "warning")
            return True  # Non-critical

    def rollback(self) -> bool:
        # Disable maintenance mode on rollback (if we enabled it)
        if self.enable:
            self.enable = False
            return self.execute()
        return True


class StopWorkersStep(UpdateStep):
    """Stop scheduler and workers, wait for completion."""

    name = "stop_workers"
    description = "Stop scheduler and workers"
    order = 20

    def execute(self) -> bool:
        self.log("Stopping scheduler and workers...")

        # Stop scheduler and workers via compose
        services_to_stop = ["scheduler", "queue-short", "queue-long"]

        for service in services_to_stop:
            cmd = self.ctx.base_cmd + ["stop", service]
            result = subprocess.run(
                cmd,
                cwd=self.ctx.compose_dir,
                env=self.ctx.env,
                capture_output=True
            )
            # Ignore errors if service doesn't exist

        self.log("Waiting for workers to finish current jobs...")
        # Give workers time to finish gracefully
        time.sleep(5)

        self.log("Workers stopped", "success")
        return True


class BackupStep(UpdateStep):
    """Create a backup before migration."""

    name = "backup"
    description = "Create database backup"
    order = 30

    def execute(self) -> bool:
        self.log("Creating backup...")

        try:
            site_name = os.environ.get("IQ_SITE_NAME", "")
            if not site_name:
                self.log("No IQ_SITE_NAME set, skipping backup", "warning")
                return True

            # Create backup via bench command
            cmd = ["bench", "--site", site_name, "backup", "--with-files"]
            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.returncode != 0:
                self.log(f"Backup failed: {result.stderr}", "error")
                self.ctx.add_error(self.name, result.stderr)
                return False

            self.log("Backup created successfully", "success")
            return True

        except Exception as e:
            self.log(f"Backup error: {e}", "error")
            self.ctx.add_error(self.name, str(e))
            return False


class TagImagesStep(UpdateStep):
    """Tag current images for rollback."""

    name = "tag_images"
    description = "Tag current images for rollback"
    order = 35
    requires_running_stack = True

    def execute(self) -> bool:
        if not self.ctx.was_running:
            self.log("Stack was not running, skipping image tagging", "info")
            return True

        self.log(f"Tagging images with: {self.ctx.rollback_tag}")

        # Get running images
        cmd = self.ctx.base_cmd + ["ps", "--format", "json"]
        result = subprocess.run(
            cmd,
            cwd=self.ctx.compose_dir,
            env=self.ctx.env,
            capture_output=True,
            text=True
        )

        if result.returncode != 0 or not result.stdout.strip():
            self.log("No running containers found", "warning")
            return True

        current_images = {}
        for line in result.stdout.strip().split("\n"):
            if not line:
                continue
            try:
                container = json.loads(line)
                service = container.get("Service", "")
                image = container.get("Image", "")
                if service and image:
                    current_images[service] = image
            except json.JSONDecodeError:
                continue

        # Tag each image
        for service, image in current_images.items():
            if ":" in image:
                base_image, _ = image.rsplit(":", 1)
            else:
                base_image = image

            rollback_image = f"{base_image}:{self.ctx.rollback_tag}"

            cmd = ["docker", "tag", image, rollback_image]
            result = subprocess.run(cmd, capture_output=True)
            if result.returncode == 0:
                # Get image ID for later comparison
                id_cmd = ["docker", "image", "inspect", image, "--format", "{% raw %}{{.Id}}{% endraw %}"]
                id_result = subprocess.run(id_cmd, capture_output=True, text=True)
                image_id = id_result.stdout.strip() if id_result.returncode == 0 else ""

                self.ctx.tagged_images[service] = {
                    "rollback_ref": rollback_image,
                    "image_id": image_id,
                    "original_ref": image
                }
                self.log(f"  Tagged {service}: {self.ctx.rollback_tag}")

        return True


class PullImagesStep(UpdateStep):
    """Pull new images from registry."""

    name = "pull_images"
    description = "Pull new images from registry"
    order = 40

    def should_skip(self) -> tuple[bool, str]:
        if not self.ctx.has_registry:
            return True, "No registry configured"
        return False, ""

    def execute(self) -> bool:
        skip, reason = self.should_skip()
        if skip:
            self.log(f"Skipping: {reason}", "info")
            return True

        self.log("Pulling new images from registry...")

        cmd = self.ctx.base_cmd + ["pull"]
        result = subprocess.run(cmd, cwd=self.ctx.compose_dir, env=self.ctx.env)

        if result.returncode != 0:
            self.log("Failed to pull images", "error")
            self.ctx.add_error(self.name, "docker compose pull failed")
            return False

        self.log("Images pulled successfully", "success")
        return True


class MigrateStep(UpdateStep):
    """Run the init service (migrations)."""

    name = "migrate"
    description = "Run database migrations (init service)"
    order = 50

    def execute(self) -> bool:
        self.log("Running init service (migrations)...")
        self.log("  Old services continue running during migration", "info")

        cmd = self.ctx.base_cmd + ["up", "init", "--wait", "--no-deps"]
        result = subprocess.run(cmd, cwd=self.ctx.compose_dir, env=self.ctx.env)

        if result.returncode != 0:
            self.log("Migration failed!", "error")
            self.ctx.add_error(self.name, "init service failed")
            return False

        self.log("Migration completed successfully", "success")
        return True


class ClearCacheStep(UpdateStep):
    """Clear Frappe/Redis caches."""

    name = "clear_cache"
    description = "Clear application caches"
    order = 55

    def execute(self) -> bool:
        self.log("Clearing caches...")

        try:
            site_name = os.environ.get("IQ_SITE_NAME", "")
            if not site_name:
                self.log("No IQ_SITE_NAME set, skipping cache clear", "warning")
                return True

            cmd = ["bench", "--site", site_name, "clear-cache"]
            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.returncode != 0:
                self.log(f"Cache clear failed: {result.stderr}", "warning")
                # Non-critical
            else:
                self.log("Cache cleared", "success")

            return True

        except Exception as e:
            self.log(f"Cache clear error: {e}", "warning")
            return True  # Non-critical


class StopOldStackStep(UpdateStep):
    """Stop the old stack after successful migration."""

    name = "stop_old"
    description = "Stop old stack (after successful migration)"
    order = 60

    def execute(self) -> bool:
        # This is now handled by compose up --force-recreate
        # Keep as placeholder for explicit stop if needed
        self.log("Old services will be replaced by new services", "info")
        return True


class StartNewStackStep(UpdateStep):
    """Start new stack with updated images."""

    name = "start_new"
    description = "Start services with new images"
    order = 70

    def execute(self) -> bool:
        self.log("Starting services with new images (brief downtime)...")

        cmd = self.ctx.base_cmd + ["up", "-d", "--force-recreate"]
        result = subprocess.run(cmd, cwd=self.ctx.compose_dir, env=self.ctx.env)

        if result.returncode != 0:
            self.log("Failed to start services!", "error")
            self.ctx.add_error(self.name, "docker compose up failed")
            return False

        self.log("Services started", "success")
        return True


class VerifyServicesStep(UpdateStep):
    """Verify all services are healthy."""

    name = "verify"
    description = "Verify services are healthy"
    order = 80

    def execute(self) -> bool:
        self.log("Verifying services...")

        time.sleep(3)  # Brief wait for containers to stabilize

        cmd = self.ctx.base_cmd + ["ps", "--filter", "status=running", "-q"]
        result = subprocess.run(
            cmd,
            cwd=self.ctx.compose_dir,
            env=self.ctx.env,
            capture_output=True,
            text=True
        )

        if not result.stdout.strip():
            self.log("No services running after update!", "error")
            self.ctx.add_error(self.name, "no running containers")
            return False

        running_count = len(result.stdout.strip().split("\n"))
        self.log(f"{running_count} services running", "success")
        return True


class CleanupRollbackImagesStep(UpdateStep):
    """Clean up rollback-tagged images."""

    name = "cleanup"
    description = "Clean up rollback images"
    order = 90

    def execute(self) -> bool:
        if not self.ctx.tagged_images:
            self.log("No rollback images to clean", "info")
            return True

        self.log("Cleaning up rollback images...")

        # Get current images
        cmd = self.ctx.base_cmd + ["ps", "--format", "json"]
        result = subprocess.run(
            cmd,
            cwd=self.ctx.compose_dir,
            env=self.ctx.env,
            capture_output=True,
            text=True
        )

        new_images = {}
        if result.returncode == 0 and result.stdout.strip():
            for line in result.stdout.strip().split("\n"):
                if not line:
                    continue
                try:
                    container = json.loads(line)
                    service = container.get("Service", "")
                    image = container.get("Image", "")
                    if service and image:
                        new_images[service] = image
                except json.JSONDecodeError:
                    continue

        removed = 0
        for service, tag_info in self.ctx.tagged_images.items():
            rollback_ref = tag_info["rollback_ref"]
            rollback_id = tag_info["image_id"]

            # Get current image ID
            current_ref = new_images.get(service, "")
            current_id = ""
            if current_ref:
                id_cmd = ["docker", "image", "inspect", current_ref, "--format", "{% raw %}{{.Id}}{% endraw %}"]
                id_result = subprocess.run(id_cmd, capture_output=True, text=True)
                current_id = id_result.stdout.strip() if id_result.returncode == 0 else ""

            # Only remove if IDs differ (actual update happened)
            if rollback_id and current_id and rollback_id != current_id:
                rm_cmd = ["docker", "rmi", rollback_ref]
                rm_result = subprocess.run(rm_cmd, capture_output=True)
                if rm_result.returncode == 0:
                    self.log(f"  Removed: {rollback_ref}")
                    removed += 1
            else:
                self.log(f"  Kept (same version): {rollback_ref}")

        self.log(f"Cleaned up {removed} rollback images", "success")
        return True


# =============================================================================
# Rollback Step (special)
# =============================================================================

class RollbackStep(UpdateStep):
    """Rollback to previously tagged images."""

    name = "rollback"
    description = "Rollback to previous images"
    order = 100
    can_run_isolated = True

    def execute(self) -> bool:
        if not self.ctx.tagged_images:
            self.log("No rollback images available", "error")
            return False

        self.log("Rolling back to previous images...")

        # Stop current containers
        stop_cmd = self.ctx.base_cmd + ["down"]
        subprocess.run(stop_cmd, cwd=self.ctx.compose_dir, env=self.ctx.env, capture_output=True)

        # Update env with rollback tag
        rollback_env = self.ctx.env.copy()
        rollback_env["IQ_IMAGE_TAG"] = self.ctx.rollback_tag

        # Start with rollback images
        up_cmd = self.ctx.base_cmd + ["up", "-d"]
        result = subprocess.run(up_cmd, cwd=self.ctx.compose_dir, env=rollback_env)

        if result.returncode == 0:
            self.log("Rollback successful - previous version restored", "success")
            return True
        else:
            self.log("Rollback failed! Manual intervention required.", "error")
            return False


# =============================================================================
# Hook System
# =============================================================================

class HookRunner:
    """Runs hooks defined in apps' hooks.py."""

    @staticmethod
    def get_hooks(hook_name: str) -> list[HookDefinition]:
        """Get all hooks for a given hook point, sorted by order."""
        hooks_by_id = {}

        try:
            installed_apps = frappe.get_installed_apps()
        except Exception:
            installed_apps = ["{{app_name}}"]

        for app_name in installed_apps:
            try:
                app_hooks = frappe.get_hooks("ops_update_hooks", app_name=app_name) or {}
                hook_list = app_hooks.get(hook_name, [])

                for hook in hook_list:
                    hook_def = HookDefinition(
                        id=hook.get("id", hook.get("function", "")),
                        order=hook.get("order", 50),
                        function=hook.get("function", ""),
                        description=hook.get("description", "")
                    )
                    # Later definitions override earlier ones (by ID)
                    hooks_by_id[hook_def.id] = hook_def

            except Exception:
                continue

        # Sort by order
        return sorted(hooks_by_id.values(), key=lambda h: h.order)

    @staticmethod
    def run_hooks(hook_name: str, ctx: UpdateContext) -> bool:
        """Run all hooks for a given hook point."""
        hooks = HookRunner.get_hooks(hook_name)

        if not hooks:
            return True

        click.echo(f"ðŸ”— Running {hook_name} hooks...")

        for hook in hooks:
            if not hook.function:
                continue

            try:
                module_path, function_name = hook.function.rsplit(".", 1)
                module = importlib.import_module(module_path)
                func = getattr(module, function_name)

                click.echo(f"   â†’ {hook.id} (order: {hook.order})")
                result = func(ctx)

                if result is False:
                    click.echo(f"   âŒ Hook {hook.id} failed")
                    return False

            except Exception as e:
                click.echo(f"   âŒ Hook {hook.id} error: {e}")
                ctx.add_error(f"hook:{hook_name}:{hook.id}", str(e))
                return False

        return True


# =============================================================================
# Update Orchestrator
# =============================================================================

class UpdateOrchestrator:
    """Orchestrates the update process with all steps and hooks."""

    # Standard step sequence for full update
    STANDARD_STEPS = [
        MaintenanceModeStep,
        StopWorkersStep,
        BackupStep,
        TagImagesStep,
        PullImagesStep,
        MigrateStep,
        ClearCacheStep,
        StopOldStackStep,
        StartNewStackStep,
        VerifyServicesStep,
        CleanupRollbackImagesStep,
    ]

    # Step name to class mapping
    STEP_MAP = {
        "maintenance": MaintenanceModeStep,
        "stop_workers": StopWorkersStep,
        "backup": BackupStep,
        "tag_images": TagImagesStep,
        "pull_images": PullImagesStep,
        "migrate": MigrateStep,
        "clear_cache": ClearCacheStep,
        "stop_old": StopOldStackStep,
        "start_new": StartNewStackStep,
        "verify": VerifyServicesStep,
        "cleanup": CleanupRollbackImagesStep,
        "rollback": RollbackStep,
    }

    def __init__(self, ctx: UpdateContext):
        self.ctx = ctx
        self.executed_steps: list[UpdateStep] = []

    def run_full_update(self) -> bool:
        """Run the complete update sequence with all hooks."""
        click.echo(f"\nðŸ”„ Starting controlled update for '{self.ctx.stage_name}'...")
        click.echo(f"   Image: {self.ctx.image_name}")
        click.echo(f"   Rollback tag: {self.ctx.rollback_tag}")
        click.echo("")

        # Pre-update hooks
        if not HookRunner.run_hooks("pre_update", self.ctx):
            click.echo("âŒ Pre-update hooks failed", err=True)
            return False

        # Run each step
        for step_class in self.STANDARD_STEPS:
            # Special handling for MaintenanceModeStep (enable mode)
            if step_class == MaintenanceModeStep:
                step = step_class(self.ctx, enable=True)
            else:
                step = step_class(self.ctx)

            # Check if step should be skipped
            skip, reason = step.should_skip()
            if skip:
                click.echo(f"â­ï¸  Skipping {step.name}: {reason}")
                continue

            # Run pre-step hook
            if not HookRunner.run_hooks(f"pre_{step.name}", self.ctx):
                click.echo(f"âŒ Pre-{step.name} hooks failed", err=True)
                self._rollback()
                return False

            # Execute step
            click.echo(f"\nðŸ“ Step: {step.description}")
            success = step.execute()

            if success:
                self.executed_steps.append(step)

                # Run post-step hook
                if not HookRunner.run_hooks(f"post_{step.name}", self.ctx):
                    click.echo(f"âŒ Post-{step.name} hooks failed", err=True)
                    self._rollback()
                    return False
            else:
                click.echo(f"\nâŒ Step '{step.name}' failed!", err=True)
                self._rollback()
                return False

        # Disable maintenance mode
        maintenance_off = MaintenanceModeStep(self.ctx, enable=False)
        maintenance_off.execute()

        # Post-update hooks
        if not HookRunner.run_hooks("post_update", self.ctx):
            click.echo("âš ï¸  Post-update hooks failed (update completed)", err=True)

        click.echo(f"\nðŸŽ‰ Stage '{self.ctx.stage_name}' updated successfully!")
        return True

    def run_single_step(self, step_name: str, **kwargs) -> bool:
        """Run a single step by name."""
        step_class = self.STEP_MAP.get(step_name)
        if not step_class:
            click.echo(f"âŒ Unknown step: {step_name}", err=True)
            click.echo(f"   Available: {', '.join(self.STEP_MAP.keys())}")
            return False

        # Special handling for MaintenanceModeStep
        if step_class == MaintenanceModeStep:
            enable = kwargs.get("enable", True)
            step = step_class(self.ctx, enable=enable)
        else:
            step = step_class(self.ctx)

        if not step.can_run_isolated:
            click.echo(f"âŒ Step '{step_name}' cannot be run in isolation", err=True)
            return False

        click.echo(f"\nðŸ“ Running step: {step.description}")
        return step.execute()

    def _rollback(self):
        """Rollback executed steps in reverse order."""
        if not self.executed_steps:
            click.echo("No steps to rollback")
            return

        click.echo("\nðŸ”„ Rolling back...")

        # If we have tagged images, do a full rollback
        if self.ctx.tagged_images:
            rollback_step = RollbackStep(self.ctx)
            rollback_step.execute()

        # Also rollback individual steps
        for step in reversed(self.executed_steps):
            try:
                step.rollback()
            except Exception as e:
                click.echo(f"âš ï¸  Rollback of {step.name} failed: {e}")

        # Disable maintenance mode
        maintenance_off = MaintenanceModeStep(self.ctx, enable=False)
        maintenance_off.execute()

    @classmethod
    def get_available_steps(cls) -> list[str]:
        """Get list of available step names."""
        return list(cls.STEP_MAP.keys())


# =============================================================================
# Helper Functions for CLI Integration
# =============================================================================

def create_update_context(
    stage_name: str,
    stage: dict,
    config: dict,
    app_root: Path,
    compose_dir: Path,
    env_dir: Path,
    base_cmd: list,
    env: dict,
    image_name: str,
    has_registry: bool,
    was_running: bool,
) -> UpdateContext:
    """Create an UpdateContext with all required data."""
    from datetime import datetime

    env_file_name = stage.get("env_file", ".env.dev")

    return UpdateContext(
        stage_name=stage_name,
        compose_dir=compose_dir,
        env_dir=env_dir,
        app_root=app_root,
        env=env,
        base_cmd=base_cmd,
        image_name=image_name,
        rollback_tag=f"pre-update-{datetime.now().strftime('%Y%m%d-%H%M%S')}",
        has_registry=has_registry,
        was_running=was_running,
        shared_env_file=env_dir / ".env",
        stage_env_file=env_dir / env_file_name,
        env_file_name=env_file_name,
    )
