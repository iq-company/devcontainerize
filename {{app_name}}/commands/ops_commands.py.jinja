"""
Bench ops CLI - Operations commands for template updates, builds, and maintenance.

Usage:
    bench ops update                 # Update from template
    bench ops version                # Show version
    bench ops version --bump         # Bump version
    bench ops build                  # Show build plan
    bench ops build --images         # Build Docker images
    bench ops test                   # Run tests
    bench ops release run/stop/clean # Manage release environment
"""

import os
import re
import subprocess
import sys
from pathlib import Path

import click


def get_app_root() -> Path:
    """Get the app root directory (where ops/ is located)."""
    return Path(__file__).parents[2]


def get_bench_root() -> Path:
    """Get the bench root directory."""
    return Path(__file__).parents[4]


# =============================================================================
# Main CLI Group
# =============================================================================

@click.group()
def ops():
    """Operations CLI for template updates, builds, and maintenance."""
    pass


# =============================================================================
# Update Command (copier Template Sync)
# =============================================================================

@ops.command("update")
@click.option("-d", "--dry", is_flag=True, help="Dry run (preview changes without applying)")
@click.option("-f", "--force", is_flag=True, help="Force update (overwrite local changes)")
def update_cmd(dry: bool, force: bool):
    """Update from devcontainerize template."""
    app_root = get_app_root()
    answers_file = app_root / "ops" / "build" / ".copier-answers.yml"

    # Fallback to legacy location
    if not answers_file.exists():
        answers_file = app_root / ".copier-answers.yml"

    cmd = ["copier", "update", "--trust"]

    if answers_file.exists():
        # copier requires relative path for answers-file
        relative_answers = answers_file.relative_to(app_root)
        cmd.extend(["--answers-file", str(relative_answers)])

    if dry:
        cmd.append("--pretend")
        click.echo("üîç Dry run - showing what would change:")

    if force:
        cmd.append("--force")

    click.echo(f"Running: {' '.join(cmd)}")
    result = subprocess.run(cmd, cwd=app_root)
    sys.exit(result.returncode)


# =============================================================================
# Version Command
# =============================================================================

@ops.command("version")
@click.option("-b", "--bump", is_flag=True, help="Bump version number")
@click.option("-m", "--major", is_flag=True, help="Bump major version (X.0.0)")
@click.option("-f", "--feature", is_flag=True, help="Bump feature version (x.X.0)")
@click.option("-c", "--commit", is_flag=True, help="Commit the version bump")
def version_cmd(bump: bool, major: bool, feature: bool, commit: bool):
    """Show or bump version number."""
    app_root = get_app_root()
    version_file = app_root / "ops" / "build" / "VERSION"
    init_file = app_root / "{{ app_name }}" / "__init__.py"

    if not version_file.exists():
        click.echo("‚ùå VERSION file not found at ops/build/VERSION")
        sys.exit(1)

    current = version_file.read_text().strip()

    if not bump:
        # Just show version
        click.echo(f"Version: {current}")

        # Also show template info if available
        answers_file = app_root / "ops" / "build" / ".copier-answers.yml"
        if not answers_file.exists():
            answers_file = app_root / ".copier-answers.yml"
        if answers_file.exists():
            click.echo(f"\nTemplate answers: {answers_file}")
        return

    # Bump version
    parts = current.split(".")
    if len(parts) != 3:
        click.echo(f"‚ùå Invalid version format: {current}")
        sys.exit(1)

    maj, minor, patch = map(int, parts)

    if major:
        new_version = f"{maj + 1}.0.0"
    elif feature:
        new_version = f"{maj}.{minor + 1}.0"
    else:  # bugfix (default)
        new_version = f"{maj}.{minor}.{patch + 1}"

    click.echo(f"Bumping version: {current} ‚Üí {new_version}")

    # Update VERSION file
    version_file.write_text(new_version + "\n")
    click.echo(f"‚úì Updated {version_file}")

    # Update __init__.py if it exists
    if init_file.exists():
        content = init_file.read_text()
        new_content = re.sub(
            r'__version__\s*=\s*"[0-9]+\.[0-9]+\.[0-9]+"',
            f'__version__ = "{new_version}"',
            content
        )
        init_file.write_text(new_content)
        click.echo(f"‚úì Updated {init_file}")

    if commit:
        subprocess.run(["git", "add", str(version_file), str(init_file)], cwd=app_root)
        subprocess.run(["git", "commit", "-m", f"chore: Bump version to {new_version}"], cwd=app_root)
        click.echo("‚úì Committed version bump")


# =============================================================================
# Build Command
# =============================================================================

@ops.command("build")
@click.option("-i", "--images", is_flag=True, help="Build Docker images (default: show plan)")
@click.option("-t", "--targets", multiple=True, help="Specific targets to build")
@click.option("-p", "--push", is_flag=True, help="Push images after building")
@click.option("-f", "--force", is_flag=True, help="Force rebuild")
def build_cmd(images: bool, targets: tuple, push: bool, force: bool):
    """Show build plan or build Docker images."""
    app_root = get_app_root()
    settings = app_root / "ops" / "build" / "build-settings.yml"

    if not settings.exists():
        click.echo(f"‚ùå Build settings not found at {settings}")
        sys.exit(1)

    if images:
        # Build images
        cmd = ["baker", "build", "--settings", str(settings)]

        if targets:
            cmd.extend(["--targets", ",".join(targets)])
        if push:
            cmd.append("--push")
        if force:
            cmd.append("--force")
    else:
        # Show plan (default)
        cmd = ["baker", "plan", "--settings", str(settings)]

    result = subprocess.run(cmd, cwd=app_root)
    sys.exit(result.returncode)


# =============================================================================
# Test Command
# =============================================================================

@ops.command("test")
@click.option("-a", "--app", "app_name", help="Run tests for a specific app")
@click.option("-m", "--module", help="Run tests for a specific module")
@click.option("-d", "--doctype", help="Run tests for a specific doctype")
@click.option("-t", "--test", "test_name", help="Run a specific test function")
@click.option("-s", "--section", help="Run tests for a specific section")
@click.option("-c", "--continue-on-error", is_flag=True, help="Continue running tests after failures")
@click.option("--site", default="test_{{ app_name }}_site", help="Test site name")
def test_cmd(app_name, module, doctype, test_name, section, continue_on_error, site):
    """Run tests."""
    bench_root = get_bench_root()

    # Ensure site name starts with test_
    if not site.startswith("test_"):
        site = f"test_{site}"

    cmd = ["bench", "--site", site, "run-iq-tests"]

    if app_name:
        cmd.extend(["--app", app_name])
    if module:
        cmd.extend(["--module", module])
    if doctype:
        cmd.extend(["--doctype", doctype])
    if test_name:
        cmd.extend(["--test", test_name])
    if section:
        cmd.extend(["--section", section])
    if continue_on_error:
        cmd.append("--continue-on-error")

    click.echo(f"Running: {' '.join(cmd)}")
    result = subprocess.run(cmd, cwd=bench_root)
    sys.exit(result.returncode)


# =============================================================================
# Release Commands
# =============================================================================

@ops.group()
def release():
    """Release environment management."""
    pass


@release.command("run")
@click.option("-e", "--env-file", type=click.Path(exists=True), help="Path to custom .env file")
def release_run(env_file):
    """Start release environment."""
    app_root = get_app_root()
    script = app_root / "ops" / "scripts" / "release" / "run_release_helper.sh"

    cmd = ["bash", str(script)]
    if env_file:
        cmd.append(env_file)

    click.echo("Starting release environment...")
    result = subprocess.run(cmd, cwd=app_root)
    sys.exit(result.returncode)


@release.command("stop")
def release_stop():
    """Stop release environment."""
    app_root = get_app_root()
    script = app_root / "ops" / "scripts" / "release" / "stop_release_helper.sh"

    click.echo("Stopping release environment...")
    result = subprocess.run(["bash", str(script)], cwd=app_root)
    sys.exit(result.returncode)


@release.command("clean")
def release_clean():
    """Clean up release environment (remove containers and volumes)."""
    app_root = get_app_root()
    script = app_root / "ops" / "scripts" / "release" / "clean_release_helper.sh"

    click.echo("Cleaning release environment...")
    result = subprocess.run(["bash", str(script)], cwd=app_root)
    sys.exit(result.returncode)


# =============================================================================
# Export commands for Frappe
# =============================================================================

commands = [ops]
