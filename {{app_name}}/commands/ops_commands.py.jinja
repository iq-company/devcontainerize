"""
Bench ops CLI - Operations commands for template updates, builds, testing, and maintenance.

Usage:
    bench ops update                 # Update from template
    bench ops version                # Show version
    bench ops version --bump         # Bump version
    bench ops build                  # Show build plan
    bench ops build --images         # Build Docker images
    bench ops run-tests              # Run tests
    bench ops release-dist           # Execute release cleanup
    bench ops release run/stop/clean # Manage release environment
"""

import importlib
import os
import re
import shutil
import subprocess
import sys
import threading
from pathlib import Path

import click
import frappe
from frappe.commands import pass_context


def get_app_root() -> Path:
    """Get the app root directory (where ops/ is located)."""
    return Path(__file__).parents[2]


def get_bench_root() -> Path:
    """Get the bench root directory."""
    return Path(__file__).parents[4]


# =============================================================================
# Main CLI Group
# =============================================================================

@click.group()
def ops():
    """Operations CLI for template updates, builds, and maintenance."""
    pass


# =============================================================================
# Update Command (copier Template Sync)
# =============================================================================

@ops.command("update")
@click.option("-d", "--dry", is_flag=True, help="Dry run (preview changes without applying)")
@click.option("-r", "--recopy", is_flag=True, help="Recopy template (ignores git status, works on dirty repos)")
def update_cmd(dry: bool, recopy: bool):
    """Update from devcontainerize template."""
    app_root = get_app_root()
    answers_file = app_root / "ops" / "build" / ".copier-answers.yml"

    # Fallback to legacy location
    if not answers_file.exists():
        answers_file = app_root / ".copier-answers.yml"

    # Use recopy for dirty repos, update for clean repos
    copier_cmd = "recopy" if recopy else "update"
    cmd = ["copier", copier_cmd, "--trust", "--defaults"]

    if answers_file.exists():
        # copier requires relative path for answers-file
        relative_answers = answers_file.relative_to(app_root)
        cmd.extend(["--answers-file", str(relative_answers)])

    if dry:
        cmd.append("--pretend")
        click.echo("üîç Dry run - showing what would change:")

    click.echo(f"Running: {' '.join(cmd)}")
    result = subprocess.run(cmd, cwd=app_root)
    sys.exit(result.returncode)


# =============================================================================
# Version Command
# =============================================================================

@ops.command("version")
@click.option("-b", "--bump", is_flag=True, help="Bump version number")
@click.option("-m", "--major", is_flag=True, help="Bump major version (X.0.0)")
@click.option("-f", "--feature", is_flag=True, help="Bump feature version (x.X.0)")
@click.option("-c", "--commit", is_flag=True, help="Commit the version bump")
def version_cmd(bump: bool, major: bool, feature: bool, commit: bool):
    """Show or bump version number."""
    app_root = get_app_root()
    version_file = app_root / "ops" / "build" / "VERSION"
    init_file = app_root / "{{ app_name }}" / "__init__.py"

    if not version_file.exists():
        click.echo("‚ùå VERSION file not found at ops/build/VERSION")
        sys.exit(1)

    current = version_file.read_text().strip()

    if not bump:
        # Just show version
        click.echo(f"Version: {current}")

        # Also show template info if available
        answers_file = app_root / "ops" / "build" / ".copier-answers.yml"
        if not answers_file.exists():
            answers_file = app_root / ".copier-answers.yml"
        if answers_file.exists():
            click.echo(f"\nTemplate answers: {answers_file}")
        return

    # Bump version
    parts = current.split(".")
    if len(parts) != 3:
        click.echo(f"‚ùå Invalid version format: {current}")
        sys.exit(1)

    maj, minor, patch = map(int, parts)

    if major:
        new_version = f"{maj + 1}.0.0"
    elif feature:
        new_version = f"{maj}.{minor + 1}.0"
    else:  # bugfix (default)
        new_version = f"{maj}.{minor}.{patch + 1}"

    click.echo(f"Bumping version: {current} ‚Üí {new_version}")

    # Update VERSION file
    version_file.write_text(new_version + "\n")
    click.echo(f"‚úì Updated {version_file}")

    # Update __init__.py if it exists
    if init_file.exists():
        content = init_file.read_text()
        new_content = re.sub(
            r'__version__\s*=\s*"[0-9]+\.[0-9]+\.[0-9]+"',
            f'__version__ = "{new_version}"',
            content
        )
        init_file.write_text(new_content)
        click.echo(f"‚úì Updated {init_file}")

    if commit:
        subprocess.run(["git", "add", str(version_file), str(init_file)], cwd=app_root)
        subprocess.run(["git", "commit", "-m", f"chore: Bump version to {new_version}"], cwd=app_root)
        click.echo("‚úì Committed version bump")


# =============================================================================
# Build Command
# =============================================================================

@ops.command("build")
@click.option("-i", "--images", is_flag=True, help="Build Docker images (default: show plan)")
@click.option("-t", "--targets", multiple=True, help="Specific targets to build")
@click.option("-p", "--push", is_flag=True, help="Push images after building")
@click.option("-f", "--force", is_flag=True, help="Force rebuild")
def build_cmd(images: bool, targets: tuple, push: bool, force: bool):
    """Show build plan or build Docker images."""
    app_root = get_app_root()
    settings = app_root / "ops" / "build" / "build-settings.yml"

    if not settings.exists():
        click.echo(f"‚ùå Build settings not found at {settings}")
        sys.exit(1)

    if images:
        # Build images
        cmd = ["baker", "build", "--settings", str(settings)]

        if targets:
            cmd.extend(["--targets", ",".join(targets)])
        if push:
            cmd.append("--push")
        if force:
            cmd.append("--force")
    else:
        # Show plan (default)
        cmd = ["baker", "plan", "--settings", str(settings)]

    result = subprocess.run(cmd, cwd=app_root)
    sys.exit(result.returncode)


# =============================================================================
# Run Tests Command
# =============================================================================

@ops.command("run-tests")
@click.option("-a", "--app", "app_filter", help="Run tests for a specific app")
@click.option("-m", "--module", help="Run tests for a specific module")
@click.option("-d", "--doctype", help="Run tests for a specific doctype")
@click.option("-t", "--test", "test_filter", help="Run a specific test function")
@click.option("-s", "--section", help="Run tests for a specific section")
@click.option("-c", "--continue-on-error", is_flag=True, help="Continue running tests after failures")
@pass_context
def run_tests_cmd(context, app_filter, module, doctype, test_filter, section, continue_on_error):
    """Run tests defined in ops_tests hooks."""
    site_name = context.sites[0] if context.sites else None
    if not site_name:
        raise frappe.SiteNotSpecifiedError

    frappe.init(site=site_name)

    # Divider lines for better visibility
    app_divider = "\n" + "=" * 80 + "\n{:^80}\n" + "=" * 80
    section_divider = "\n" + "-" * 60 + "\n{:^60}\n" + "-" * 60
    result_divider = "\n" + "=" * 100 + "\n{:^100}\n" + "=" * 100

    # Store test results for summary
    results = {"passed": [], "failed": []}
    skip_on_first_error = not continue_on_error

    installed_apps = frappe.get_installed_apps()

    for app_name in installed_apps:
        # Skip app if filter is provided and doesn't match
        if app_filter and app_filter != app_name:
            continue

        # Get ops_tests hooks from the current app
        app_ops_tests = frappe.get_hooks("ops_tests", app_name=app_name)

        if not app_ops_tests:
            continue

        # Print app header with clear divider
        print(app_divider.format(f" TESTS FOR APP: {app_name.upper()} "))

        for test_section in app_ops_tests:
            # Only run specific section if requested
            if section and test_section.get("section") != section:
                continue

            # Print section header
            section_name = test_section.get("section", "Unnamed section")
            print(section_divider.format(f" SECTION: {section_name} "))

            for step in test_section.get("steps", []):
                run_cmd = f"bench --site {frappe.local.site} run-tests"
                test_params = []
                step_descriptor = ""

                # Add app as first parameter
                test_params.append(f"--app {app_name}")

                if "doctype" in step:
                    test_doctype = step["doctype"]
                    if doctype and doctype != test_doctype:
                        continue
                    test_params.append(f"--doctype \"{test_doctype}\"")
                    step_descriptor = f"DocType: {test_doctype}"

                elif "module" in step:
                    if module and module != step["module"]:
                        continue
                    module_path = step["module"]
                    test_params.append(f"--module {module_path}")
                    step_descriptor = f"Module: {module_path}"

                    if "tests" in step:
                        test_args = []
                        for test_name in step["tests"]:
                            if test_filter and test_filter != test_name:
                                continue
                            test_args.append(f"--test {test_name}")
                            step_descriptor += f", Test: {test_name}"
                        if test_args:
                            test_params.extend(test_args)

                test_params.append("--skip-test-records")
                full_cmd = f"{run_cmd} {' '.join(test_params)}"

                print(f"\n> EXECUTING: {full_cmd}\n")

                def reader_thread(pipe, queue):
                    try:
                        with pipe:
                            for line in iter(pipe.readline, b''):
                                line_str = line.decode('utf-8')
                                queue.append(line_str)
                                print(line_str, end='', flush=True)
                    finally:
                        pass

                process = subprocess.Popen(
                    full_cmd, shell=True,
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=1
                )

                stdout_lines, stderr_lines = [], []
                stdout_thread = threading.Thread(target=reader_thread, args=[process.stdout, stdout_lines])
                stderr_thread = threading.Thread(target=reader_thread, args=[process.stderr, stderr_lines])
                stdout_thread.start()
                stderr_thread.start()

                return_code = process.wait()
                stdout_thread.join()
                stderr_thread.join()

                output = ''.join(stdout_lines) + ''.join(stderr_lines)
                has_failure = return_code != 0 or any(p in output for p in ["FAILED", "FAIL:", "ERROR:", "Traceback", "AssertionError"])

                test_result = {
                    "app": app_name, "section": section_name, "step": step_descriptor,
                    "command": full_cmd, "return_code": return_code, "output": output
                }

                if not has_failure:
                    results["passed"].append(test_result)
                    print(f"\n‚úÖ PASSED: {step_descriptor}")
                else:
                    results["failed"].append(test_result)
                    print(f"\n‚ùå FAILED: {step_descriptor}")
                    if skip_on_first_error:
                        print("\nStopping tests due to error. Use --continue-on-error to run all tests.")
                        break

                print("\n" + "-" * 40)

            if skip_on_first_error and results["failed"]:
                break
        if skip_on_first_error and results["failed"]:
            break

    # Print summary
    print(result_divider.format(" TEST RESULTS SUMMARY "))

    if results["passed"]:
        print(f"\n‚úÖ PASSED TEST UNITS: {len(results['passed'])}")
        for i, r in enumerate(results["passed"], 1):
            print(f"  {i}. App: {r['app']}, Section: {r['section']}, {r['step']}")

    if results["failed"]:
        print(f"\n‚ùå FAILED TESTS: {len(results['failed'])}")
        for i, r in enumerate(results["failed"], 1):
            print(f"  {i}. App: {r['app']}, Section: {r['section']}, {r['step']}")
            print(f"     Command: {r['command']}")

    if results["failed"]:
        print("\nüõë Some tests failed.")
        sys.exit(1)
    elif not (results["passed"] or results["failed"]):
        print("\n‚ö†Ô∏è No tests were run!")
        sys.exit(0)
    else:
        print(f"\n‚úÖ All {len(results['passed'])} tests passed!")
        sys.exit(0)


# =============================================================================
# Release Dist Command
# =============================================================================

@ops.command("release-dist")
def release_dist_cmd():
    """Execute release cleanup tasks defined in ops_release_cleanup hooks."""
    all_cleanup_tasks = []

    linked_apps = frappe.get_all_apps(False, os.path.join(frappe.utils.get_bench_path(), "sites"))

    for app_name in linked_apps:
        all_cleanup_tasks.extend(frappe.get_hooks("ops_release_cleanup", app_name=app_name))

    during_build = False if shutil.which("docker") else True

    for cleanup_task in all_cleanup_tasks:
        if "context" in cleanup_task and cleanup_task["context"] == "only_during_build" and not during_build:
            continue

        if "function" in cleanup_task:
            function_path = cleanup_task["function"]
            module_path, function_name = function_path.rsplit(".", 1)
            try:
                module = importlib.import_module(module_path)
                function = getattr(module, function_name)
                print(f"Executing function: {function_path}")
                function()
            except Exception as e:
                print(f"Error executing function {function_path}: {e}")

        elif "bash" in cleanup_task:
            bash_command = cleanup_task["bash"]
            print(f"Executing bash command: {bash_command}")
            try:
                subprocess.run(bash_command, shell=True, check=True)
            except subprocess.CalledProcessError as e:
                print(f"Error executing bash command: {e}")

        elif "script" in cleanup_task:
            for app_name in linked_apps:
                script_path = os.path.join(frappe.get_app_path(app_name), cleanup_task["script"])
                if os.path.exists(script_path):
                    print(f"Executing script: {script_path}")
                    try:
                        if script_path.endswith(".py"):
                            subprocess.run([sys.executable, script_path], check=True)
                        else:
                            subprocess.run(["bash", script_path], check=True)
                    except subprocess.CalledProcessError as e:
                        print(f"Error executing script: {e}")
                    break


# =============================================================================
# Release Environment Commands
# =============================================================================

@ops.group()
def release():
    """Release environment management."""
    pass


@release.command("run")
@click.option("-e", "--env-file", type=click.Path(exists=True), help="Path to custom .env file")
def release_run(env_file):
    """Start release environment."""
    app_root = get_app_root()
    script = app_root / "ops" / "scripts" / "release" / "run_release_helper.sh"

    cmd = ["bash", str(script)]
    if env_file:
        cmd.append(env_file)

    click.echo("Starting release environment...")
    result = subprocess.run(cmd, cwd=app_root)
    sys.exit(result.returncode)


@release.command("stop")
def release_stop():
    """Stop release environment."""
    app_root = get_app_root()
    script = app_root / "ops" / "scripts" / "release" / "stop_release_helper.sh"

    click.echo("Stopping release environment...")
    result = subprocess.run(["bash", str(script)], cwd=app_root)
    sys.exit(result.returncode)


@release.command("clean")
def release_clean():
    """Clean up release environment (remove containers and volumes)."""
    app_root = get_app_root()
    script = app_root / "ops" / "scripts" / "release" / "clean_release_helper.sh"

    click.echo("Cleaning release environment...")
    result = subprocess.run(["bash", str(script)], cwd=app_root)
    sys.exit(result.returncode)


# =============================================================================
# Export commands for Frappe
# =============================================================================

commands = [ops]
