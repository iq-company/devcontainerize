"""
Bench ops CLI - Operations commands for template updates, builds, testing, and maintenance.

Usage:
    bench ops update                     # Update from template
    bench ops version                    # Show version
    bench ops version --bump             # Bump version
    bench ops build                      # Show build plan
    bench ops build --images             # Build Docker images
    bench ops run-tests                  # Run tests
    bench ops release-dist               # Execute release cleanup
    bench ops stage ls                   # List all stages
    bench ops stage show <stage>         # Show stage details
    bench ops stage run <stage>          # Start stage environment
    bench ops stage stop <stage>         # Stop stage environment
    bench ops stage clean <stage>        # Clean stage environment
    bench ops stage build <stage>        # Build images for stage
    bench ops stage add                  # Add a new stage
    bench ops stage rm <stage>           # Remove a stage
"""

import importlib
import os
import re
import shutil
import subprocess
import sys
import threading
from pathlib import Path
from typing import Optional

import click
import frappe
import yaml
from frappe.commands import pass_context


def get_app_root() -> Path:
    """Get the app root directory (where ops/ is located)."""
    return Path(__file__).parents[2]


def get_bench_root() -> Path:
    """Get the bench root directory."""
    return Path(__file__).parents[4]


# =============================================================================
# Main CLI Group
# =============================================================================

@click.group()
def ops():
    """Operations CLI for template updates, builds, and maintenance."""
    pass


# =============================================================================
# Update Command (copier Template Sync)
# =============================================================================

@ops.command("update")
@click.option("-d", "--dry", is_flag=True, help="Dry run (preview changes without applying)")
@click.option("-r", "--recopy", is_flag=True, help="Recopy template (ignores git status, works on dirty repos)")
def update_cmd(dry: bool, recopy: bool):
    """Update from devcontainerize template."""
    app_root = get_app_root()
    answers_file = app_root / "ops" / "build" / ".copier-answers.yml"

    # Fallback to legacy location
    if not answers_file.exists():
        answers_file = app_root / ".copier-answers.yml"

    # Use recopy for dirty repos, update for clean repos
    copier_cmd = "recopy" if recopy else "update"
    cmd = ["copier", copier_cmd, "--trust", "--defaults"]

    if answers_file.exists():
        # copier requires relative path for answers-file
        relative_answers = answers_file.relative_to(app_root)
        cmd.extend(["--answers-file", str(relative_answers)])

    if dry:
        cmd.append("--pretend")
        click.echo("üîç Dry run - showing what would change:")

    click.echo(f"Running: {' '.join(cmd)}")
    result = subprocess.run(cmd, cwd=app_root)
    sys.exit(result.returncode)


# =============================================================================
# Version Command
# =============================================================================

@ops.command("version")
@click.option("-b", "--bump", is_flag=True, help="Bump version number")
@click.option("-m", "--major", is_flag=True, help="Bump major version (X.0.0)")
@click.option("-f", "--feature", is_flag=True, help="Bump feature version (x.X.0)")
@click.option("-c", "--commit", is_flag=True, help="Commit the version bump")
def version_cmd(bump: bool, major: bool, feature: bool, commit: bool):
    """Show or bump version number."""
    app_root = get_app_root()
    version_file = app_root / "ops" / "build" / "VERSION"
    init_file = app_root / "{{ app_name }}" / "__init__.py"

    if not version_file.exists():
        click.echo("‚ùå VERSION file not found at ops/build/VERSION")
        sys.exit(1)

    current = version_file.read_text().strip()

    if not bump:
        # Just show version
        click.echo(f"Version: {current}")

        # Also show template info if available
        answers_file = app_root / "ops" / "build" / ".copier-answers.yml"
        if not answers_file.exists():
            answers_file = app_root / ".copier-answers.yml"
        if answers_file.exists():
            click.echo(f"\nTemplate answers: {answers_file}")
        return

    # Bump version
    parts = current.split(".")
    if len(parts) != 3:
        click.echo(f"‚ùå Invalid version format: {current}")
        sys.exit(1)

    maj, minor, patch = map(int, parts)

    if major:
        new_version = f"{maj + 1}.0.0"
    elif feature:
        new_version = f"{maj}.{minor + 1}.0"
    else:  # bugfix (default)
        new_version = f"{maj}.{minor}.{patch + 1}"

    click.echo(f"Bumping version: {current} ‚Üí {new_version}")

    # Update VERSION file
    version_file.write_text(new_version + "\n")
    click.echo(f"‚úì Updated {version_file}")

    # Update __init__.py if it exists
    if init_file.exists():
        content = init_file.read_text()
        new_content = re.sub(
            r'__version__\s*=\s*"[0-9]+\.[0-9]+\.[0-9]+"',
            f'__version__ = "{new_version}"',
            content
        )
        init_file.write_text(new_content)
        click.echo(f"‚úì Updated {init_file}")

    if commit:
        subprocess.run(["git", "add", str(version_file), str(init_file)], cwd=app_root)
        subprocess.run(["git", "commit", "-m", f"chore: Bump version to {new_version}"], cwd=app_root)
        click.echo("‚úì Committed version bump")


# =============================================================================
# Build Command
# =============================================================================

@ops.command("build")
@click.option("-i", "--images", is_flag=True, help="Build Docker images (default: show plan)")
@click.option("-t", "--targets", multiple=True, help="Specific targets to build")
@click.option("-p", "--push", is_flag=True, help="Push images after building")
@click.option("-f", "--force", is_flag=True, help="Force rebuild")
def build_cmd(images: bool, targets: tuple, push: bool, force: bool):
    """Show build plan or build Docker images."""
    app_root = get_app_root()
    settings = app_root / "ops" / "build" / "build-settings.yml"

    if not settings.exists():
        click.echo(f"‚ùå Build settings not found at {settings}")
        sys.exit(1)

    if images:
        # Build images
        cmd = ["baker", "build", "--settings", str(settings)]

        if targets:
            cmd.extend(["--targets", ",".join(targets)])
        if push:
            cmd.append("--push")
        if force:
            cmd.append("--force")
    else:
        # Show plan (default)
        cmd = ["baker", "plan", "--settings", str(settings)]

    result = subprocess.run(cmd, cwd=app_root)
    sys.exit(result.returncode)


# =============================================================================
# Run Tests Command
# =============================================================================

@ops.command("run-tests")
@click.option("-a", "--app", "app_filter", help="Run tests for a specific app")
@click.option("-m", "--module", help="Run tests for a specific module")
@click.option("-d", "--doctype", help="Run tests for a specific doctype")
@click.option("-t", "--test", "test_filter", help="Run a specific test function")
@click.option("-s", "--section", help="Run tests for a specific section")
@click.option("-c", "--continue-on-error", is_flag=True, help="Continue running tests after failures")
@pass_context
def run_tests_cmd(context, app_filter, module, doctype, test_filter, section, continue_on_error):
    """Run tests defined in ops_tests hooks."""
    site_name = context.sites[0] if context.sites else None
    if not site_name:
        raise frappe.SiteNotSpecifiedError

    frappe.init(site=site_name)

    # Divider lines for better visibility
    app_divider = "\n" + "=" * 80 + "\n{:^80}\n" + "=" * 80
    section_divider = "\n" + "-" * 60 + "\n{:^60}\n" + "-" * 60
    result_divider = "\n" + "=" * 100 + "\n{:^100}\n" + "=" * 100

    # Store test results for summary
    results = {"passed": [], "failed": []}
    skip_on_first_error = not continue_on_error

    installed_apps = frappe.get_installed_apps()

    for app_name in installed_apps:
        # Skip app if filter is provided and doesn't match
        if app_filter and app_filter != app_name:
            continue

        # Get ops_tests hooks from the current app
        app_ops_tests = frappe.get_hooks("ops_tests", app_name=app_name)

        if not app_ops_tests:
            continue

        # Print app header with clear divider
        print(app_divider.format(f" TESTS FOR APP: {app_name.upper()} "))

        for test_section in app_ops_tests:
            # Only run specific section if requested
            if section and test_section.get("section") != section:
                continue

            # Print section header
            section_name = test_section.get("section", "Unnamed section")
            print(section_divider.format(f" SECTION: {section_name} "))

            for step in test_section.get("steps", []):
                run_cmd = f"bench --site {frappe.local.site} run-tests"
                test_params = []
                step_descriptor = ""

                # Add app as first parameter
                test_params.append(f"--app {app_name}")

                if "doctype" in step:
                    test_doctype = step["doctype"]
                    if doctype and doctype != test_doctype:
                        continue
                    test_params.append(f"--doctype \"{test_doctype}\"")
                    step_descriptor = f"DocType: {test_doctype}"

                elif "module" in step:
                    if module and module != step["module"]:
                        continue
                    module_path = step["module"]
                    test_params.append(f"--module {module_path}")
                    step_descriptor = f"Module: {module_path}"

                    if "tests" in step:
                        test_args = []
                        for test_name in step["tests"]:
                            if test_filter and test_filter != test_name:
                                continue
                            test_args.append(f"--test {test_name}")
                            step_descriptor += f", Test: {test_name}"
                        if test_args:
                            test_params.extend(test_args)

                test_params.append("--skip-test-records")
                full_cmd = f"{run_cmd} {' '.join(test_params)}"

                print(f"\n> EXECUTING: {full_cmd}\n")

                def reader_thread(pipe, queue):
                    try:
                        with pipe:
                            for line in iter(pipe.readline, b''):
                                line_str = line.decode('utf-8')
                                queue.append(line_str)
                                print(line_str, end='', flush=True)
                    finally:
                        pass

                process = subprocess.Popen(
                    full_cmd, shell=True,
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=1
                )

                stdout_lines, stderr_lines = [], []
                stdout_thread = threading.Thread(target=reader_thread, args=[process.stdout, stdout_lines])
                stderr_thread = threading.Thread(target=reader_thread, args=[process.stderr, stderr_lines])
                stdout_thread.start()
                stderr_thread.start()

                return_code = process.wait()
                stdout_thread.join()
                stderr_thread.join()

                output = ''.join(stdout_lines) + ''.join(stderr_lines)
                has_failure = return_code != 0 or any(p in output for p in ["FAILED", "FAIL:", "ERROR:", "Traceback", "AssertionError"])

                test_result = {
                    "app": app_name, "section": section_name, "step": step_descriptor,
                    "command": full_cmd, "return_code": return_code, "output": output
                }

                if not has_failure:
                    results["passed"].append(test_result)
                    print(f"\n‚úÖ PASSED: {step_descriptor}")
                else:
                    results["failed"].append(test_result)
                    print(f"\n‚ùå FAILED: {step_descriptor}")
                    if skip_on_first_error:
                        print("\nStopping tests due to error. Use --continue-on-error to run all tests.")
                        break

                print("\n" + "-" * 40)

            if skip_on_first_error and results["failed"]:
                break
        if skip_on_first_error and results["failed"]:
            break

    # Print summary
    print(result_divider.format(" TEST RESULTS SUMMARY "))

    if results["passed"]:
        print(f"\n‚úÖ PASSED TEST UNITS: {len(results['passed'])}")
        for i, r in enumerate(results["passed"], 1):
            print(f"  {i}. App: {r['app']}, Section: {r['section']}, {r['step']}")

    if results["failed"]:
        print(f"\n‚ùå FAILED TESTS: {len(results['failed'])}")
        for i, r in enumerate(results["failed"], 1):
            print(f"  {i}. App: {r['app']}, Section: {r['section']}, {r['step']}")
            print(f"     Command: {r['command']}")

    if results["failed"]:
        print("\nüõë Some tests failed.")
        sys.exit(1)
    elif not (results["passed"] or results["failed"]):
        print("\n‚ö†Ô∏è No tests were run!")
        sys.exit(0)
    else:
        print(f"\n‚úÖ All {len(results['passed'])} tests passed!")
        sys.exit(0)


# =============================================================================
# Release Dist Command
# =============================================================================

@ops.command("release-dist")
@click.option("-s", "--stage", "stage_name", help="Filter hooks for specific stage")
def release_dist_cmd(stage_name: Optional[str]):
    """Execute release cleanup tasks defined in ops_release_cleanup hooks."""
    all_cleanup_tasks = []

    linked_apps = frappe.get_all_apps(False, os.path.join(frappe.utils.get_bench_path(), "sites"))

    for app in linked_apps:
        all_cleanup_tasks.extend(frappe.get_hooks("ops_release_cleanup", app_name=app))

    during_build = False if shutil.which("docker") else True

    if stage_name:
        click.echo(f"üéØ Filtering hooks for stage: {stage_name}")

    for cleanup_task in all_cleanup_tasks:
        # Context filter (only_during_build)
        if "context" in cleanup_task and cleanup_task["context"] == "only_during_build" and not during_build:
            continue

        # Stage filter - if "stages" is defined, only run for matching stages
        task_stages = cleanup_task.get("stages")
        if task_stages and stage_name:
            if stage_name not in task_stages:
                continue
        elif task_stages and not stage_name:
            # If task has specific stages but no stage is provided, run it (backwards compat)
            pass

        if "function" in cleanup_task:
            function_path = cleanup_task["function"]
            module_path, function_name = function_path.rsplit(".", 1)
            try:
                module = importlib.import_module(module_path)
                function = getattr(module, function_name)
                print(f"Executing function: {function_path}")
                function()
            except Exception as e:
                print(f"Error executing function {function_path}: {e}")

        elif "bash" in cleanup_task:
            bash_command = cleanup_task["bash"]
            print(f"Executing bash command: {bash_command}")
            try:
                subprocess.run(bash_command, shell=True, check=True)
            except subprocess.CalledProcessError as e:
                print(f"Error executing bash command: {e}")

        elif "script" in cleanup_task:
            for app in linked_apps:
                script_path = os.path.join(frappe.get_app_path(app), cleanup_task["script"])
                if os.path.exists(script_path):
                    print(f"Executing script: {script_path}")
                    try:
                        if script_path.endswith(".py"):
                            subprocess.run([sys.executable, script_path], check=True)
                        else:
                            subprocess.run(["bash", script_path], check=True)
                    except subprocess.CalledProcessError as e:
                        print(f"Error executing script: {e}")
                    break


# =============================================================================
# Stage Configuration Helpers
# =============================================================================

def load_stages_config() -> dict:
    """Load and parse stages.yml configuration."""
    app_root = get_app_root()
    stages_file = app_root / "ops" / "build" / "stages.yml"

    if not stages_file.exists():
        click.echo(f"‚ùå Stages configuration not found: {stages_file}")
        sys.exit(1)

    with open(stages_file) as f:
        return yaml.safe_load(f)


def get_stage_config(config: dict, stage_name: str) -> dict:
    """Get resolved stage configuration (with inheritance)."""
    stages = config.get("stages", {})

    if stage_name not in stages:
        available = ", ".join(stages.keys()) if stages else "none"
        click.echo(f"‚ùå Stage '{stage_name}' not found. Available: {available}")
        sys.exit(1)

    stage = stages[stage_name].copy()

    # Resolve inheritance
    if "extends" in stage:
        parent_name = stage["extends"]
        parent = get_stage_config(config, parent_name)
        # Merge parent with child (child overrides parent)
        merged = parent.copy()
        del stage["extends"]
        for key, value in stage.items():
            if key == "apps" and "apps" in merged:
                # For apps, merge by name
                merged_apps = {app["name"]: app for app in merged.get("apps", [])}
                for app in value:
                    merged_apps[app["name"]] = app
                merged["apps"] = list(merged_apps.values())
            elif key == "profiles" and "profiles" in merged:
                # For profiles, use child's value (complete override)
                merged["profiles"] = value
            else:
                merged[key] = value
        stage = merged

    return stage


def get_stage_apps(config: dict, stage_name: str) -> list:
    """Get apps for a specific stage, with ref overrides and ignores applied."""
    base_apps = config.get("apps", [])
    stage = get_stage_config(config, stage_name)
    stage_app_overrides = {app["name"]: app for app in stage.get("apps", [])}

    resolved_apps = []
    for app in base_apps:
        override = stage_app_overrides.get(app["name"], {})

        # Skip ignored apps
        if override.get("ignore", False):
            continue

        app_copy = app.copy()
        if override:
            app_copy.update(override)
        resolved_apps.append(app_copy)

    return resolved_apps


def stage_has_custom_apps(config: dict, stage_name: str) -> bool:
    """Check if a stage has customized apps (different from base)."""
    base_apps = config.get("apps", [])
    stage_apps = get_stage_apps(config, stage_name)

    # Different number of apps
    if len(base_apps) != len(stage_apps):
        return True

    # Check each app
    base_by_name = {app["name"]: app for app in base_apps}
    for stage_app in stage_apps:
        base_app = base_by_name.get(stage_app["name"])
        if not base_app:
            return True
        # Compare refs
        if stage_app.get("ref") != base_app.get("ref"):
            return True

    return False


def validate_stage_config(config: dict, stage_name: str) -> list[str]:
    """Validate stage configuration. Returns list of warnings/errors."""
    stages = config.get("stages", {})
    raw_stage = stages.get(stage_name, {})
    resolved_stage = get_stage_config(config, stage_name)
    issues = []

    # Check if target is missing AND stage doesn't extend another
    # (extending stages inherit target, so no warning needed)
    if "target" not in raw_stage and "extends" not in raw_stage:
        issues.append(
            f"‚ö†Ô∏è  Stage '{stage_name}' has no 'target' defined. "
            "Consider adding explicit target (e.g., dev, release, release-alpine)."
        )

    has_custom = stage_has_custom_apps(config, stage_name)
    has_suffix = bool(resolved_stage.get("image_suffix"))

    if has_custom and not has_suffix:
        issues.append(
            f"‚ö†Ô∏è  Stage '{stage_name}' has custom apps but no image_suffix. "
            "A separate image build requires image_suffix to be set."
        )

    return issues


def get_compose_files(stage: dict) -> list[str]:
    """Get list of compose files for a stage."""
    app_root = get_app_root()
    compose_dir = app_root / "ops" / "compose"

    files = [compose_dir / "compose.base.yml"]

    # Add profile-specific compose files
    profiles = stage.get("profiles", [])
    if "db" in profiles:
        dbms = os.environ.get("DBMS", "postgres")
        db_file = compose_dir / f"compose.{dbms}.yml"
        if db_file.exists():
            files.append(db_file)

    # Always include release compose
    release_file = compose_dir / "compose.release.yml"
    if release_file.exists():
        files.append(release_file)

    return [str(f) for f in files if f.exists()]


def get_stages_that_extend(config: dict, stage_name: str) -> list[str]:
    """Find all stages that extend the given stage."""
    stages = config.get("stages", {})
    extending = []
    for name, stage in stages.items():
        if stage.get("extends") == stage_name:
            extending.append(name)
    return extending


def get_stage_image_name(config: dict, stage_name: str, image_prefix: str = "{{ image_prefix }}") -> str:
    """Get the full image name for a stage.

    Image name is derived from: {image_prefix}-{target}{suffix}
    The target name directly maps to the image name suffix.
    """
    stage = get_stage_config(config, stage_name)
    target = stage.get("target", "release")
    suffix = stage.get("image_suffix", "")

    # Image name follows pattern: {prefix}-{target}{suffix}
    # e.g., iq-dev, iq-release, iq-release-alpine, iq-release-prod
    return f"{image_prefix}-{target}{suffix}"


# =============================================================================
# Stage Commands
# =============================================================================

@ops.group()
def stage():
    """Stage management (environments, builds, deployments)."""
    pass


@stage.command("ls")
@click.option("-v", "--verbose", is_flag=True, help="Show more details")
def stage_ls(verbose: bool):
    """List all defined stages."""
    config = load_stages_config()
    stages = config.get("stages", {})

    if not stages:
        click.echo("No stages defined in ops/build/stages.yml")
        return

    click.echo("üì¶ Stages:")
    all_issues = []
    for name, raw_stage in stages.items():
        resolved = get_stage_config(config, name)
        extends = f" (extends: {raw_stage['extends']})" if "extends" in raw_stage else ""
        target = resolved.get("target", "release")
        click.echo(f"  ‚Ä¢ {name}{extends} ‚Üí {target}")

        if verbose:
            click.echo(f"      env: {resolved.get('env_file', '.env')}")
            profiles = resolved.get("profiles", [])
            if profiles:
                click.echo(f"      profiles: {', '.join(profiles)}")
            suffix = resolved.get("image_suffix", "")
            if suffix:
                click.echo(f"      image_suffix: {suffix}")
            if stage_has_custom_apps(config, name):
                click.echo("      apps: (customized)")

        # Collect validation issues
        all_issues.extend(validate_stage_config(config, name))

    if all_issues:
        click.echo("")
        for issue in all_issues:
            click.echo(issue)


@stage.command("show")
@click.argument("stage_name")
def stage_show(stage_name: str):
    """Show detailed configuration for a stage."""
    config = load_stages_config()
    stage = get_stage_config(config, stage_name)
    apps = get_stage_apps(config, stage_name)
    has_custom = stage_has_custom_apps(config, stage_name)

    click.echo(f"üì¶ Stage: {stage_name}")
    click.echo(f"   target: {stage.get('target', 'release')}")
    click.echo(f"   env_file: {stage.get('env_file', '.env')}")
    click.echo(f"   profiles: {', '.join(stage.get('profiles', [])) or '(none)'}")

    suffix = stage.get("image_suffix", "")
    image_name = get_stage_image_name(config, stage_name)
    click.echo(f"   image: {image_name}")
    if suffix:
        click.echo(f"   image_suffix: {suffix}")

    click.echo(f"\nüì± Apps{' (customized)' if has_custom else ''}:")
    for app in apps:
        source = app.get("source", "unknown")
        ref = app.get("ref", "HEAD")
        click.echo(f"   ‚Ä¢ {app['name']}: {source} @ {ref}")

    # Show validation warnings
    issues = validate_stage_config(config, stage_name)
    if issues:
        click.echo("")
        for issue in issues:
            click.echo(issue)


@stage.command("run")
@click.argument("stage_name")
@click.option("-d", "--detach", is_flag=True, default=True, help="Run in background (default)")
@click.option("-f", "--foreground", is_flag=True, help="Run in foreground")
def stage_run(stage_name: str, detach: bool, foreground: bool):
    """Start environment for a stage."""
    config = load_stages_config()
    stage = get_stage_config(config, stage_name)
    app_root = get_app_root()
    compose_dir = app_root / "ops" / "compose"

    # Determine env file
    env_file = compose_dir / stage.get("env_file", ".env")

    # Build compose command
    compose_files = get_compose_files(stage)
    cmd = ["docker", "compose"]

    for f in compose_files:
        cmd.extend(["-f", f])

    if env_file.exists():
        cmd.extend(["--env-file", str(env_file)])

    # Add profiles
    for profile in stage.get("profiles", []):
        cmd.extend(["--profile", profile])

    cmd.append("up")

    if not foreground:
        cmd.append("-d")

    click.echo(f"üöÄ Starting stage '{stage_name}'...")
    click.echo(f"   Compose files: {', '.join(Path(f).name for f in compose_files)}")
    click.echo(f"   Env file: {env_file.name if env_file.exists() else '(none)'}")
    click.echo(f"   Profiles: {', '.join(stage.get('profiles', [])) or '(none)'}")
    click.echo(f"\n   Running: {' '.join(cmd)}\n")

    result = subprocess.run(cmd, cwd=compose_dir)
    sys.exit(result.returncode)


@stage.command("stop")
@click.argument("stage_name")
def stage_stop(stage_name: str):
    """Stop environment for a stage."""
    config = load_stages_config()
    stage = get_stage_config(config, stage_name)
    app_root = get_app_root()
    compose_dir = app_root / "ops" / "compose"

    compose_files = get_compose_files(stage)
    cmd = ["docker", "compose"]

    for f in compose_files:
        cmd.extend(["-f", f])

    # Add profiles (needed to stop profile-specific services)
    for profile in stage.get("profiles", []):
        cmd.extend(["--profile", profile])

    cmd.append("stop")

    click.echo(f"üõë Stopping stage '{stage_name}'...")
    result = subprocess.run(cmd, cwd=compose_dir)
    sys.exit(result.returncode)


@stage.command("clean")
@click.argument("stage_name")
@click.option("-v", "--volumes", is_flag=True, help="Also remove volumes")
def stage_clean(stage_name: str, volumes: bool):
    """Clean up environment for a stage (remove containers)."""
    config = load_stages_config()
    stage = get_stage_config(config, stage_name)
    app_root = get_app_root()
    compose_dir = app_root / "ops" / "compose"

    compose_files = get_compose_files(stage)
    cmd = ["docker", "compose"]

    for f in compose_files:
        cmd.extend(["-f", f])

    for profile in stage.get("profiles", []):
        cmd.extend(["--profile", profile])

    cmd.append("down")

    if volumes:
        cmd.append("-v")

    click.echo(f"üßπ Cleaning stage '{stage_name}'...")
    result = subprocess.run(cmd, cwd=compose_dir)
    sys.exit(result.returncode)


@stage.command("build")
@click.argument("stage_name")
@click.option("-p", "--push", is_flag=True, help="Push images after building")
@click.option("-f", "--force", is_flag=True, help="Force rebuild")
def stage_build(stage_name: str, push: bool, force: bool):
    """Build Docker images for a stage."""
    config = load_stages_config()
    stage = get_stage_config(config, stage_name)
    apps = get_stage_apps(config, stage_name)
    app_root = get_app_root()
    has_custom = stage_has_custom_apps(config, stage_name)

    # Get target from stage config (defaults applied in get_stage_config)
    target = stage.get("target", "release")
    image_suffix = stage.get("image_suffix", "")
    image_name = get_stage_image_name(config, stage_name)

    # Validate configuration
    issues = validate_stage_config(config, stage_name)
    if issues:
        for issue in issues:
            click.echo(issue)
        if has_custom and not image_suffix:
            click.echo("\n‚ùå Cannot build: stage has custom apps but no image_suffix.")
            click.echo("   Set image_suffix in stages.yml to create a distinct image.")
            sys.exit(1)

    click.echo(f"üî® Building images for stage '{stage_name}'...")
    click.echo(f"   target: {target}")
    click.echo(f"   image: {image_name}")
    if has_custom:
        click.echo("   apps: (customized)")

    # Extract Frappe ref and custom apps from stage definition
    # The main app ({{ app_name }}) is copied via COPY in Dockerfile, so it's not in CUSTOM_APPS
    # All other apps are passed via CUSTOM_APPS in format: url#ref or /local/path
    frappe_ref = None
    custom_apps = []

    click.echo("\nüì± Apps:")
    for app in apps:
        source = app.get("source", "local")
        ref = app.get("ref", "HEAD")
        click.echo(f"     ‚Ä¢ {app['name']}: {source} @ {ref}")

        if app["name"] == "frappe":
            # Frappe is handled separately via FRAPPE_REF
            frappe_ref = ref
        elif app["name"] == "{{ app_name }}":
            # Main app is copied via COPY in Dockerfile, not via CUSTOM_APPS
            pass
        else:
            # All other apps go into CUSTOM_APPS
            if source == "local":
                # Local path (must exist in container at build time)
                app_spec = f"/opt/apps/{app['name']}"
            else:
                # Remote URL with optional ref
                app_spec = source
                if ref and ref != "HEAD":
                    app_spec += f"#{ref}"
            custom_apps.append(app_spec)

    # Build command using baker
    settings = app_root / "ops" / "build" / "build-settings.yml"

    if not settings.exists():
        click.echo(f"\n‚ùå Build settings not found: {settings}")
        sys.exit(1)

    cmd = ["baker", "build", "--settings", str(settings)]
    cmd.extend(["--targets", target])

    if push:
        cmd.append("--push")
    if force:
        cmd.append("--force")

    # Build args for the Docker build
    # These are passed as environment variables which Dockerfile ARGs pick up
    env = os.environ.copy()
    env["STAGE_NAME"] = stage_name
    env["IMAGE_SUFFIX"] = image_suffix

    # Production build for release targets, development for dev target
    is_production = target != "dev"
    env["PRODUCTION_BUILD"] = "true" if is_production else "false"

    if frappe_ref:
        env["FRAPPE_REF"] = frappe_ref
        click.echo(f"\n   FRAPPE_REF: {frappe_ref}")

    if custom_apps:
        env["CUSTOM_APPS"] = ",".join(custom_apps)
        click.echo(f"   CUSTOM_APPS: {env['CUSTOM_APPS']}")

    click.echo(f"   PRODUCTION_BUILD: {env['PRODUCTION_BUILD']}")

    click.echo(f"\n   Running: {' '.join(cmd)}\n")
    result = subprocess.run(cmd, cwd=app_root, env=env)
    sys.exit(result.returncode)


@stage.command("add")
@click.argument("stage_name")
@click.option("-e", "--extends", "extends_stage", help="Stage to extend from")
@click.option("-t", "--target", "target_name", help="Build target (dev, release, release-alpine, ...)")
def stage_add(stage_name: str, extends_stage: Optional[str], target_name: Optional[str]):
    """Add a new stage."""
    config = load_stages_config()
    stages = config.get("stages", {})

    if stage_name in stages:
        click.echo(f"‚ùå Stage '{stage_name}' already exists.")
        sys.exit(1)

    # Ask if it should extend another stage
    if extends_stage is None:
        existing_stages = list(stages.keys())
        if existing_stages:
            click.echo(f"Available stages to extend: {', '.join(existing_stages)}")
            extends_stage = click.prompt(
                "Extend from stage (leave empty for standalone)",
                default="",
                show_default=False
            )
            if extends_stage and extends_stage not in stages:
                click.echo(f"‚ùå Stage '{extends_stage}' not found.")
                sys.exit(1)

    # Determine target - inherited from parent or must be specified
    if extends_stage:
        # Will inherit target from parent, no need to specify
        pass
    elif target_name is None:
        # Standalone stage needs explicit target
        target_name = click.prompt(
            "Build target (e.g., dev, release, release-alpine)",
            default="release"
        )

    # Create new stage configuration
    new_stage = {
        "env_file": f".env.{stage_name}",
        "profiles": [],
        "image_suffix": f"-{stage_name}"
    }

    # Add target only for standalone stages (extending stages inherit it)
    if not extends_stage and target_name:
        new_stage["target"] = target_name

    if extends_stage:
        new_stage = {"extends": extends_stage, **new_stage}

    # Update the config file
    app_root = get_app_root()
    stages_file = app_root / "ops" / "build" / "stages.yml"

    config["stages"][stage_name] = new_stage

    with open(stages_file, "w") as f:
        yaml.dump(config, f, default_flow_style=False, sort_keys=False)

    click.echo(f"‚úÖ Added stage '{stage_name}'")

    # Create env file using init_env_files script (generates unique credentials)
    compose_dir = app_root / "ops" / "compose"
    env_file = compose_dir / f".env.{stage_name}"

    if not env_file.exists():
        if click.confirm(f"Create {env_file.name} with fresh credentials?", default=True):
            # Use init_env_files script to generate env with unique credentials
            init_script = app_root / "ops" / "scripts" / "devcontainer" / "init_env_files"

            if init_script.exists():
                result = subprocess.run(
                    ["bash", str(init_script)],
                    cwd=app_root,
                    env={**os.environ, "ENV_FILE_SUFFIX": f".{stage_name}"}
                )
                if env_file.exists():
                    click.echo(f"‚úÖ Created {env_file.name} with fresh credentials")
                else:
                    click.echo(f"‚ö†Ô∏è  Script ran but {env_file.name} was not created")
            else:
                click.echo(f"‚ö†Ô∏è  Script not found: {init_script}")
                env_file.touch()
                click.echo(f"‚úÖ Created empty {env_file.name}")


@stage.command("rm")
@click.argument("stage_name")
@click.option("-y", "--yes", is_flag=True, help="Skip confirmation prompts")
@click.option("-n", "--no", "no_delete_env", is_flag=True, help="Don't delete .env file")
def stage_rm(stage_name: str, yes: bool, no_delete_env: bool):
    """Remove a stage."""
    config = load_stages_config()
    stages = config.get("stages", {})

    if stage_name not in stages:
        available = ", ".join(stages.keys()) if stages else "none"
        click.echo(f"‚ùå Stage '{stage_name}' not found. Available: {available}")
        sys.exit(1)

    # Check if other stages extend this one
    extending = get_stages_that_extend(config, stage_name)
    if extending:
        click.echo(f"‚ùå Cannot remove stage '{stage_name}'.")
        click.echo(f"   The following stages extend it: {', '.join(extending)}")
        click.echo("   Remove or modify those stages first.")
        sys.exit(1)

    if not yes:
        if not click.confirm(f"Remove stage '{stage_name}'?"):
            click.echo("Cancelled.")
            return

    # Get env file before removing stage
    stage = stages[stage_name]
    env_filename = stage.get("env_file", f".env.{stage_name}")

    # Remove stage from config
    del config["stages"][stage_name]

    app_root = get_app_root()
    stages_file = app_root / "ops" / "build" / "stages.yml"

    with open(stages_file, "w") as f:
        yaml.dump(config, f, default_flow_style=False, sort_keys=False)

    click.echo(f"‚úÖ Removed stage '{stage_name}'")

    # Handle env file deletion
    compose_dir = app_root / "ops" / "compose"
    env_file = compose_dir / env_filename

    if env_file.exists() and env_filename != ".env":  # Don't delete base .env
        if no_delete_env:
            click.echo(f"   Kept {env_file.name}")
        elif yes or click.confirm(f"Delete {env_file.name}?", default=False):
            env_file.unlink()
            click.echo(f"‚úÖ Deleted {env_file.name}")
        else:
            click.echo(f"   Kept {env_file.name}")


# =============================================================================
# Export commands for Frappe
# =============================================================================

commands = [ops]
